<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PAC-FISH ‚Äî Salva a los Peces Nativos</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #89f7fe, #66a6ff);
      font-family: 'Comic Sans MS', cursive, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      color: #2c3e50;
    }
    h1 {
      font-size: 1.8rem;
      text-align: center;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    #game-container {
      position: relative;
      margin: 10px auto;
      box-shadow: 0 8px 25px rgba(0,0,0,0.2);
      border-radius: 16px;
      overflow: hidden;
      background: #001f3f;
    }
    canvas {
      display: block;
      background: #001f3f;
      image-rendering: pixelated;
    }
    .hud {
      display: flex;
      justify-content: space-around;
      width: 100%;
      max-width: 600px;
      padding: 12px;
      background: rgba(0,31,63,0.8);
      border-radius: 12px;
      margin-top: 10px;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
    }
    .btn {
      padding: 10px 20px;
      margin: 10px 5px;
      font-size: 1rem;
      border: none;
      border-radius: 50px;
      background: #2ecc71;
      color: white;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .btn:hover { background: #27ae60; }
    .btn:active { transform: scale(0.98); }
    .message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      font-size: 1.2rem;
      max-width: 80%;
      z-index: 100;
      display: none;
    }
    .hide-badge {
      background: #27ae60;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.9rem;
      display: none;
    }
    @media (max-width: 600px) {
      h1 { font-size: 1.4rem; }
      .hud { flex-direction: column; gap: 8px; }
    }
  </style>
</head>
<body>
  <h1>üê† PAC-FISH: ¬°Salva a los Peces Nativos!</h1>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="message" class="message"></div>
  </div>
  <div class="hud">
    <div>Nivel: <span id="level">1</span></div>
    <div>Vidas: <span id="lives">3</span></div>
    <div>Puntos: <span id="score">0</span></div>
    <div><span id="hide-indicator" class="hide-badge">¬°Escondido!</span></div>
  </div>
  <button id="startBtn" class="btn">‚ñ∂Ô∏è Iniciar Juego</button>
  <button id="pauseBtn" class="btn">‚è∏Ô∏è Pausa</button>

  <script>
    // Configuraci√≥n del juego
    const CONFIG = {
      cols: 19,
      rows: 19,
      tileSize: 28,
      initialLives: 3,
      maxLevel: 5,
      truchasBase: 2,
      nativeSpeed: 3.5,
      truchaSpeedBase: 2.8
    };

    // Estado del juego
    const state = {
      canvas: null,
      ctx: null,
      map: [],
      player: null,
      truchas: [],
      level: 1,
      lives: CONFIG.initialLives,
      score: 0,
      pellets: 0,
      running: false,
      paused: false,
      lastTime: 0,
      hideActive: false,
      hideTimer: 0,
      speedBoost: false,
      speedBoostTimer: 0,
      gameOver: false
    };

    // Inicializar
    window.onload = function() {
      state.canvas = document.getElementById('gameCanvas');
      state.ctx = state.canvas.getContext('2d');
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      setupControls();
      showStartMessage();
    };

    function resizeCanvas() {
      const margin = 80;
      const availWidth = window.innerWidth - margin;
      const availHeight = window.innerHeight - margin - 200;
      const maxSize = Math.min(availWidth, availHeight);
      CONFIG.tileSize = Math.floor(maxSize / Math.max(CONFIG.cols, CONFIG.rows));
      if (CONFIG.tileSize < 14) CONFIG.tileSize = 14;
      state.canvas.width = CONFIG.cols * CONFIG.tileSize;
      state.canvas.height = CONFIG.rows * CONFIG.tileSize;
    }

    function setupControls() {
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('pauseBtn').addEventListener('click', togglePause);

      window.addEventListener('keydown', (e) => {
        if (!state.player) return;
        const key = e.key.toLowerCase();
        if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
          e.preventDefault();
          if (key === 'arrowup' || key === 'w') state.player.nextDir = { x: 0, y: -1 };
          if (key === 'arrowdown' || key === 's') state.player.nextDir = { x: 0, y: 1 };
          if (key === 'arrowleft' || key === 'a') state.player.nextDir = { x: -1, y: 0 };
          if (key === 'arrowright' || key === 'd') state.player.nextDir = { x: 1, y: 0 };
        }
      });
    }

    function startGame() {
      state.level = 1;
      state.lives = CONFIG.initialLives;
      state.score = 0;
      state.gameOver = false;
      startLevel(state.level);
      gameLoop(0);
    }

    function togglePause() {
      state.paused = !state.paused;
      document.getElementById('pauseBtn').textContent = state.paused ? '‚ñ∂Ô∏è Reanudar' : '‚è∏Ô∏è Pausa';
    }

    function startLevel(level) {
      generateMap();
      state.player = {
        x: Math.floor(CONFIG.cols / 2) + 0.5,
        y: Math.floor(CONFIG.rows / 2) + 0.5,
        dir: { x: 0, y: 0 },
        nextDir: { x: 0, y: 0 }
      };

      // Generar truchas
      state.truchas = [];
      const truchaCount = Math.min(6, CONFIG.truchasBase + Math.floor(level / 2));
      for (let i = 0; i < truchaCount; i++) {
        let x, y;
        do {
          x = Math.floor(Math.random() * (CONFIG.cols - 4)) + 2 + 0.5;
          y = Math.floor(Math.random() * (CONFIG.rows - 4)) + 2 + 0.5;
        } while (isColliding(x, y) || distance(x, y, state.player.x, state.player.y) < 5);
        state.truchas.push({
          x,
          y,
          dir: { x: 0, y: 0 },
          speed: CONFIG.truchaSpeedBase + level * 0.2
        });
      }

      state.pellets = countPellets();
      state.hideActive = false;
      state.speedBoost = false;
      state.running = true;
      updateHUD();
    }

    function generateMap() {
      state.map = Array(CONFIG.rows).fill().map(() => Array(CONFIG.cols).fill(2)); // 2 = pellet

      // Bordes
      for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
          if (r === 0 || c === 0 || r === CONFIG.rows - 1 || c === CONFIG.cols - 1) {
            state.map[r][c] = 1; // 1 = pared
          }
        }
      }

      // Obst√°culos internos
      const blocks = [
        { r: 3, c: 3, h: 3, w: 3 },
        { r: 3, c: CONFIG.cols - 6, h: 3, w: 3 },
        { r: CONFIG.rows - 6, c: 3, h: 3, w: 3 },
        { r: CONFIG.rows - 6, c: CONFIG.cols - 6, h: 3, w: 3 },
        { r: Math.floor(CONFIG.rows / 2) - 1, c: Math.floor(CONFIG.cols / 2) - 2, h: 3, w: 4 }
      ];

      blocks.forEach(block => {
        for (let dr = 0; dr < block.h; dr++) {
          for (let dc = 0; dc < block.w; dc++) {
            const r = block.r + dr;
            const c = block.c + dc;
            if (r > 0 && c > 0 && r < CONFIG.rows - 1 && c < CONFIG.cols - 1) {
              state.map[r][c] = 1;
            }
          }
        }
      });

      // Escondites (plantas)
      state.map.__hides = [
        { r: 1, c: 1 }, { r: 1, c: CONFIG.cols - 3 },
        { r: CONFIG.rows - 3, c: 1 }, { r: CONFIG.rows - 3, c: CONFIG.cols - 3 }
      ];
      state.map.__hides.forEach(h => {
        for (let dr = 0; dr < 2; dr++) {
          for (let dc = 0; dc < 2; dc++) {
            const r = h.r + dr;
            const c = h.c + dc;
            if (r > 0 && c > 0 && r < CONFIG.rows - 1 && c < CONFIG.cols - 1) {
              state.map[r][c] = 3; // 3 = escondite
            }
          }
        }
      });

      // Power-ups (caracoles)
      let powerups = 0;
      while (powerups < 3 && powerups < state.pellets / 5) {
        const r = Math.floor(Math.random() * (CONFIG.rows - 4)) + 2;
        const c = Math.floor(Math.random() * (CONFIG.cols - 4)) + 2;
        if (state.map[r][c] === 2) {
          state.map[r][c] = 4; // 4 = power-up
          powerups++;
        }
      }
    }

    function countPellets() {
      let count = 0;
      for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
          if (state.map[r][c] === 2) count++;
        }
      }
      return count;
    }

    function isColliding(x, y) {
      const radius = 0.45;
      const minR = Math.floor(y - radius);
      const maxR = Math.floor(y + radius);
      const minC = Math.floor(x - radius);
      const maxC = Math.floor(x + radius);

      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          if (r < 0 || c < 0 || r >= CONFIG.rows || c >= CONFIG.cols) return true;
          if (state.map[r][c] === 1) return true;
        }
      }
      return false;
    }

    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }

    function tryMove(entity, dirX, dirY, speed, delta) {
      const nx = entity.x + dirX * speed * (delta / 1000);
      const ny = entity.y + dirY * speed * (delta / 1000);
      if (!isColliding(nx, ny)) {
        entity.x = nx;
        entity.y = ny;
        return true;
      }
      if (dirX !== 0 && !isColliding(entity.x + dirX * speed * (delta / 1000), entity.y)) {
        entity.x += dirX * speed * (delta / 1000);
        return true;
      }
      if (dirY !== 0 && !isColliding(entity.x, entity.y + dirY * speed * (delta / 1000))) {
        entity.y += dirY * speed * (delta / 1000);
        return true;
      }
      return false;
    }

    function update(delta) {
      if (!state.running || state.paused || state.gameOver) return;

      const now = performance.now();

      // Temporizadores
      if (state.hideActive && now > state.hideTimer) {
        state.hideActive = false;
        document.getElementById('hide-indicator').style.display = 'none';
      }
      if (state.speedBoost && now > state.speedBoostTimer) {
        state.speedBoost = false;
      }

      // Movimiento del jugador
      if (state.player.nextDir.x !== 0 || state.player.nextDir.y !== 0) {
        const testX = state.player.x + state.player.nextDir.x * 0.3;
        const testY = state.player.y + state.player.nextDir.y * 0.3;
        if (!isColliding(testX, testY)) {
          state.player.dir = { ...state.player.nextDir };
        }
      }

      const playerSpeed = state.speedBoost ? CONFIG.nativeSpeed * 1.8 : CONFIG.nativeSpeed;
      tryMove(state.player, state.player.dir.x, state.player.dir.y, playerSpeed, delta);

      // Limites
      state.player.x = Math.max(0.6, Math.min(CONFIG.cols - 0.6, state.player.x));
      state.player.y = Math.max(0.6, Math.min(CONFIG.rows - 0.6, state.player.y));

      // Interacci√≥n con el mapa
      const pr = Math.floor(state.player.y);
      const pc = Math.floor(state.player.x);

      if (state.map[pr][pc] === 2) {
        state.map[pr][pc] = 0;
        state.score += 10;
        state.pellets--;
        updateHUD();
        if (state.pellets <= 0) nextLevel();
      } else if (state.map[pr][pc] === 3 && !state.hideActive) {
        state.hideActive = true;
        state.hideTimer = now + 5000;
        document.getElementById('hide-indicator').style.display = 'inline';
      } else if (state.map[pr][pc] === 4) {
        state.map[pr][pc] = 0;
        state.speedBoost = true;
        state.speedBoostTimer = now + 6000;
        state.score += 30;
        updateHUD();
      }

      // IA de truchas
      state.truchas.forEach(trucha => {
        const dx = state.player.x - trucha.x;
        const dy = state.player.y - trucha.y;
        const dist = distance(state.player.x, state.player.y, trucha.x, trucha.y);

        if (dist < 8) {
          trucha.dir.x = Math.abs(dx) > Math.abs(dy) ? Math.sign(dx) : 0;
          trucha.dir.y = Math.abs(dx) > Math.abs(dy) ? 0 : Math.sign(dy);
        } else {
          if (Math.random() < 0.02) {
            const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
            trucha.dir = dirs[Math.floor(Math.random() * 4)];
          }
        }

        tryMove(trucha, trucha.dir.x, trucha.dir.y, trucha.speed, delta);

        // Colisi√≥n con jugador
        if (!state.hideActive && distance(trucha.x, trucha.y, state.player.x, state.player.y) < 0.7) {
          loseLife();
        }
      });
    }

    function loseLife() {
      state.lives--;
      updateHUD();
      showMessage("¬°AY! Una trucha me atrap√≥ üò¢", 1200);
      if (state.lives <= 0) {
        gameOver();
      } else {
        // Reiniciar posici√≥n
        state.player.x = Math.floor(CONFIG.cols / 2) + 0.5;
        state.player.y = Math.floor(CONFIG.rows / 2) + 0.5;
        state.player.dir = { x: 0, y: 0 };
        state.hideActive = false;
        document.getElementById('hide-indicator').style.display = 'none';
      }
    }

    function gameOver() {
      state.running = false;
      state.gameOver = true;
      showMessage("¬°JUEGO TERMINADO! üòî\nLas truchas invasoras ganaron...\nPero puedes intentarlo de nuevo. ¬°Los peces nativos te necesitan!", 5000);
    }

    function nextLevel() {
      state.level++;
      if (state.level > CONFIG.maxLevel) {
        state.running = false;
        showMessage("üéâ ¬°FELICIDADES! üéâ\nSalvaste a los peces nativos de todas las truchas.\n¬°Comparte este logro y ayuda a proteger los r√≠os reales!", 6000);
      } else {
        showMessage(`¬°Nivel ${state.level} completado! ‚≠ê\n¬°Sigue salvando a los peces nativos!`, 2000);
        setTimeout(() => startLevel(state.level), 2100);
      }
    }

    function draw() {
      const ctx = state.ctx;
      const tile = CONFIG.tileSize;

      // Fondo
      ctx.fillStyle = '#001f3f';
      ctx.fillRect(0, 0, state.canvas.width, state.canvas.height);

      // Dibujar mapa
      for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
          const x = c * tile;
          const y = r * tile;

          if (state.map[r][c] === 1) {
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x, y, tile, tile);
          } else if (state.map[r][c] === 2) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + tile/2, y + tile/2, tile * 0.15, 0, Math.PI * 2);
            ctx.fill();
          } else if (state.map[r][c] === 3) {
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(x + 2, y + 2, tile - 4, tile - 4);
            // Dibujar hojitas
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(x + tile/3, y + tile/4, tile * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + tile*2/3, y + tile*3/4, tile * 0.1, 0, Math.PI * 2);
            ctx.fill();
          } else if (state.map[r][c] === 4) {
            // Caracol power-up
            ctx.fillStyle = '#F39C12';
            ctx.beginPath();
            ctx.arc(x + tile/2, y + tile/2, tile * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x + tile/2 + 2, y + tile/2 - 2, tile * 0.06, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // Dibujar jugador (pez nativo)
      const px = state.player.x * tile;
      const py = state.player.y * tile;
      ctx.save();
      ctx.translate(px + tile/2, py + tile/2);

      // Cuerpo
      ctx.fillStyle = '#FF6B6B';
      ctx.beginPath();
      ctx.ellipse(0, 0, tile * 0.35, tile * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      // Ojo
     
