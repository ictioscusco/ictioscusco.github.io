<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PAC-SWIM — Corregido</title>
<style>
  :root { --ui-bg: rgba(255,255,255,0.95); --accent: #2f8f66; --muted:#666; }
  html,body{ height:100%; margin:0; }
  body{ font-family: Inter, Arial, Helvetica, sans-serif; background: linear-gradient(#e8fbf3,#dff6f0); overflow:hidden; display:flex; flex-direction:column; }
  #topbar { background:var(--ui-bg); padding:10px 14px; display:flex; gap:12px; align-items:center; box-shadow:0 6px 18px rgba(0,0,0,0.06); z-index:10; }
  #title { font-weight:700; color:#083; margin-right:6px; }
  #controls { margin-left:auto; display:flex; gap:8px; align-items:center; }
  .btn { padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:white; cursor:pointer; }
  .btn.primary { background:var(--accent); color:white; border:none; }
  #info { font-size:0.95rem; color:var(--muted); margin-left:8px; }
  #gamewrap { position:relative; flex:1 1 auto; display:flex; }
  canvas { display:block; background: linear-gradient(#022,#013); width:100%; height:100%; }
  #overlay { position:absolute; left:12px; top:14px; color:white; text-shadow:0 2px 6px rgba(0,0,0,0.6); z-index:5; }
  #hud { position:absolute; right:12px; top:14px; color:white; z-index:5; text-align:right; }
  #chooser { display:flex; gap:8px; align-items:center; }
  select { padding:6px 8px; border-radius:8px; }
  #message { position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:20; pointer-events:none; }
  .panel { background: rgba(0,0,0,0.5); color:white; padding:18px 22px; border-radius:12px; text-align:center; pointer-events:all; }
  small{ color:#ccc; display:block; margin-top:8px; font-size:0.9rem; }
  @media (max-width:640px){ #topbar { padding:8px; } .btn { padding:6px 8px; } }
</style>
</head>
<body>
  <div id="topbar">
    <div id="title">PAC-SWIM</div>

    <div id="chooser">
      <label for="fishType">Elegir pez:</label>
      <select id="fishType">
        <option value="orestia">Orestia (equilibrado)</option>
        <option value="sardina">Sardina (rápida, pequeño inicio)</option>
        <option value="bagre">Bagre (lento, gran inicio)</option>
      </select>
    </div>

    <div id="info">Objetivo: come pellets y peces más pequeños; evita truchas más grandes</div>

    <div id="controls">
      <button id="btnStart" class="btn primary">Iniciar</button>
      <button id="btnPause" class="btn">Pausa</button>
      <button id="btnReset" class="btn">Reiniciar</button>
    </div>
  </div>

  <div id="gamewrap">
    <canvas id="c"></canvas>

    <div id="overlay">
      <div id="statusText">Mov: ratón / tacto. Comer pellets para crecer.</div>
    </div>

    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Tamaño: <span id="size">0</span></div>
      <div>Truchas: <span id="ghostsCount">0</span></div>
    </div>

    <div id="message">
      <div class="panel">
        <h2 id="msgTitle">Has muerto</h2>
        <div id="msgBody"></div>
        <div style="margin-top:12px;">
          <button id="respawn" class="btn primary">Volver a jugar</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* Versión corregida: se solucionó un typo (SETTINGSpelletCount) que detenía el loop,
   y se inicializa mouse.worldX/Y para que player se mueva aunque no hayas movido el ratón. */

/* SETTINGS */
const SETTINGS = {
  worldW: 2400, worldH: 1600,
  pelletCount: 900, pelletMass: 1.0,
  nativeCount: 10, troutCount: 8,
  safeSpawnRadius: 260,
  playerStartMass: 18, sardinaStartMass: 12, bagreStartMass: 28,
  massToRadius: (m)=> Math.sqrt(m) * 3,
  eatFactor: 0.65,
  troutAggroRange: 240,
  troutSpeedBase: 120, nativeSpeedBase: 160, playerSpeedBase: 220,
  friction: 0.98,
  pelletRespawn: true
};

function rand(min,max){ return min + Math.random()*(max-min); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* Canvas & world */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight - document.getElementById('topbar').offsetHeight;
canvas.width = W; canvas.height = H;
window.addEventListener('resize', ()=>{ W = window.innerWidth; H = window.innerHeight - document.getElementById('topbar').offsetHeight; canvas.width = W; canvas.height = H; });

const world = { w: SETTINGS.worldW, h: SETTINGS.worldH };
const camera = { x: world.w/2, y: world.h/2, zoom: 1 };

/* State */
let player = null, pellets = [], natives = [], trouts = [];
let running = false, paused = false, lastTime = performance.now(), mouse = { x:0, y:0, worldX:0, worldY:0, down:false }, score = 0;

/* Input */
canvas.addEventListener('mousemove', (e)=>{ const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; mouse.worldX = camera.x - W/2/camera.zoom + mouse.x/camera.zoom; mouse.worldY = camera.y - H/2/camera.zoom + mouse.y/camera.zoom; });
canvas.addEventListener('mousedown', ()=> mouse.down=true);
canvas.addEventListener('mouseup', ()=> mouse.down=false);
canvas.addEventListener('touchstart', (e)=> { mouse.down=true; e.preventDefault(); mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; mouse.worldX = camera.x - W/2/camera.zoom + mouse.x/camera.zoom; mouse.worldY = camera.y - H/2/camera.zoom + mouse.y/camera.zoom; }, {passive:false});
canvas.addEventListener('touchmove', (e)=> { e.preventDefault(); mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; mouse.worldX = camera.x - W/2/camera.zoom + mouse.x/camera.zoom; mouse.worldY = camera.y - H/2/camera.zoom + mouse.y/camera.zoom; }, {passive:false});
canvas.addEventListener('touchend', ()=> mouse.down=false);
window.addEventListener('keydown', (e)=>{ const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','w','a','s','d','W','A','S','D']; if (keys.includes(e.key)) e.preventDefault(); });

/* Entities */
class Fish {
  constructor(x,y,mass,color,type='native'){
    this.x=x; this.y=y; this.vx=0; this.vy=0; this.mass=mass; this.r = SETTINGS.massToRadius(this.mass);
    this.color=color||'#fff'; this.type=type; this.target=null; this.dead=false; this.lastEat=0;
  }
  updateRadius(){ this.r = SETTINGS.massToRadius(this.mass); }
  getSpeedBase(){ if (this.type==='player') return SETTINGS.playerSpeedBase; if (this.type==='native') return SETTINGS.nativeSpeedBase; if (this.type==='trout') return SETTINGS.troutSpeedBase; return 120; }
  getSpeed(){ const base=this.getSpeedBase(); return base / (1 + Math.sqrt(this.mass)*0.05); }
  applyMovement(dx,dy,dt){
    const s = this.getSpeed();
    const len = Math.hypot(dx,dy) || 1;
    const nx = dx/len, ny = dy/len;
    this.vx = nx * s; this.vy = ny * s;
    this.x += this.vx * dt; this.y += this.vy * dt;
    this.x = clamp(this.x, this.r+4, world.w - (this.r+4));
    this.y = clamp(this.y, this.r+4, world.h - (this.r+4));
  }
}

/* Spawn helpers */
function spawnPellets(n){
  for (let i=0;i<n;i++){
    pellets.push({ x: rand(20, world.w-20), y: rand(20, world.h-20), mass: SETTINGS.pelletMass, r: SETTINGS.massToRadius(SETTINGS.pelletMass), color: '#ffd54f' });
  }
}
function spawnNatives(n){
  for (let i=0;i<n;i++){
    const x = rand(60, world.w-60), y = rand(60, world.h-60), mass = rand(6,26);
    const nf = new Fish(x,y,mass,'#9ae0ff','native');
    // give some initial small velocity to see movement
    nf.vx = rand(-30,30); nf.vy = rand(-30,30);
    natives.push(nf);
  }
}
function spawnTrouts(n, safeZone){
  for (let i=0;i<n;i++){
    let tries=0;
    while(tries<500){
      tries++;
      const x = rand(60, world.w-60), y = rand(60, world.h-60);
      const dd = Math.hypot(x - safeZone.x, y - safeZone.y);
      if (dd > safeZone.r + 80) {
        const mass = Math.random() < 0.3 ? rand(40,110) : rand(18,45);
        const t = new Fish(x,y,mass,'#ff7b7b','trout');
        t.vx = rand(-20,20); t.vy = rand(-20,20);
        trouts.push(t);
        break;
      }
    }
  }
}

/* Player setup */
function createPlayer(type){
  const centerX = world.w/2, centerY = world.h/2;
  let mass = SETTINGS.playerStartMass;
  if (type === 'sardina') mass = SETTINGS.sardinaStartMass;
  if (type === 'bagre') mass = SETTINGS.bagreStartMass;
  player = new Fish(centerX, centerY, mass, '#ffd54f','player');
  player.updateRadius();
}

/* Init game */
function initGame(){
  pellets=[]; natives=[]; trouts=[]; score=0;
  const chosen = document.getElementById('fishType').value;
  createPlayer(chosen);
  // ensure mouse.worldX/Y has a sensible default so player moves even if cursor hasn't moved yet
  mouse.worldX = player.x; mouse.worldY = player.y;
  spawnPellets(SETTINGS.pelletCount);
  spawnNatives(SETTINGS.nativeCount);
  spawnTrouts(SETTINGS.troutCount, {x: player.x, y: player.y, r: SETTINGS.safeSpawnRadius});
  running = true; paused = false;
  document.getElementById('message').style.display = 'none';
  updateHUD();
}

/* Eating logic */
function tryEat(pred, prey){
  if (prey.dead) return false;
  if (pred.r > prey.r * 1.08 && dist(pred,prey) < pred.r - prey.r*0.25) {
    prey.dead = true;
    pred.mass += prey.mass * SETTINGS.eatFactor;
    pred.updateRadius();
    if (pred.type === 'player') score += Math.round(prey.mass*2);
    return true;
  }
  return false;
}
function tryEatPellet(f, pelletIndex){
  const p = pellets[pelletIndex];
  const d = Math.hypot(f.x - p.x, f.y - p.y);
  if (d < f.r - p.r*0.2) {
    f.mass += p.mass * SETTINGS.eatFactor;
    f.updateRadius();
    pellets.splice(pelletIndex,1);
    if (f.type === 'player') score += 1;
    return true;
  }
  return false;
}

/* AI */
function updateNatives(dt){
  natives.forEach(n => {
    let found=null, best=1e9;
    for (let i=0;i<pellets.length;i++){
      const p = pellets[i]; const d = Math.hypot(p.x - n.x, p.y - n.y);
      if (d < best && d < 320) { best = d; found = p; }
    }
    if (found) n.applyMovement(found.x - n.x, found.y - n.y, dt);
    else {
      if (!n.target || Math.random()<0.01) n.target = { x: n.x + rand(-220,220), y: n.y + rand(-220,220) };
      n.applyMovement(n.target.x - n.x, n.target.y - n.y, dt);
    }
    trouts.forEach(t=>{ const d = Math.hypot(t.x - n.x, t.y - n.y); if (t.mass > n.mass * 1.2 && d < 260) n.applyMovement(n.x - t.x, n.y - t.y, dt); });
    for (let i=pellets.length-1;i>=0;i--) tryEatPellet(n, i);
  });
}

function updateTrouts(dt){
  trouts.forEach(t=>{
    const dPlayer = Math.hypot(player.x - t.x, player.y - t.y);
    if (t.mass > player.mass * 1.06 && dPlayer < SETTINGS.troutAggroRange) t.applyMovement(player.x - t.x, player.y - t.y, dt);
    else {
      let target=null, best=1e9;
      natives.forEach(n=>{ const d = Math.hypot(n.x - t.x, n.y - t.y); if (d < best) { best = d; target = n; }});
      if (!target) for (let p of pellets){ const d = Math.hypot(p.x - t.x, p.y - t.y); if (d < best) { best = d; target = p; } }
      if (target) t.applyMovement(target.x - t.x, target.y - t.y, dt);
      else { if (!t.target || Math.random()<0.005) t.target = { x: t.x + rand(-240,240), y: t.y + rand(-240,240) }; t.applyMovement(t.target.x - t.x, t.target.y - t.y, dt); }
    }
    for (let i=pellets.length-1;i>=0;i--){ const eaten = tryEatPellet(t,i); if (eaten && SETTINGS.pelletRespawn) spawnPellets(1); }
    for (let i=natives.length-1;i>=0;i--){ const nat = natives[i]; if (!nat.dead && tryEat(t, nat)) natives.splice(i,1); }
  });
}

/* Player update */
function updatePlayer(dt){
  const tx = mouse.worldX || player.x, ty = mouse.worldY || player.y;
  if (mouse.down || true) player.applyMovement(tx - player.x, ty - player.y, dt);
  else { player.x += player.vx * dt; player.y += player.vy * dt; }
  for (let i=pellets.length-1;i>=0;i--) tryEatPellet(player,i);
  for (let i=natives.length-1;i>=0;i--){ const nat = natives[i]; if (!nat.dead && tryEat(player, nat)) natives.splice(i,1); }
  for (let i=trouts.length-1;i>=0;i--){ const t = trouts[i]; if (tryEat(player, t)){ trouts.splice(i,1); setTimeout(()=> spawnTrouts(1, {x: player.x, y: player.y, r: SETTINGS.safeSpawnRadius}), 3000); } else if (tryEat(t, player)){ gameOver('Te comió una trucha más grande'); return; } }
}

/* Main update */
function update(dt){
  if (!running || paused) return;
  camera.x = player.x; camera.y = player.y;
  updateNatives(dt);
  updateTrouts(dt);
  updatePlayer(dt);
  if (pellets.length < SETTINGS.pelletCount && SETTINGS.pelletRespawn) spawnPellets(SETTINGS.pelletCount - pellets.length); // CORREGIDO
  updateHUD();
}

/* Rendering */
function worldToScreen(x,y){ const sx = (x - camera.x) * camera.zoom + W/2; const sy = (y - camera.y) * camera.zoom + H/2; return { x: sx, y: sy }; }

function draw(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#012'); g.addColorStop(1,'#00121a'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  for (let p of pellets){ const s = worldToScreen(p.x,p.y); ctx.beginPath(); ctx.fillStyle = p.color; ctx.arc(s.x, s.y, p.r * camera.zoom, 0, Math.PI*2); ctx.fill(); }
  for (let n of natives){ const s = worldToScreen(n.x,n.y); ctx.beginPath(); ctx.fillStyle = n.color; ctx.ellipse(s.x, s.y, n.r*1.2*camera.zoom, n.r*0.8*camera.zoom, 0, 0, Math.PI*2); ctx.fill(); }
  for (let t of trouts){ const s = worldToScreen(t.x,t.y); ctx.beginPath(); ctx.fillStyle = t.color; ctx.ellipse(s.x, s.y, t.r*1.3*camera.zoom, t.r*0.9*camera.zoom, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(s.x - t.r*0.2*camera.zoom, s.y - t.r*0.25*camera.zoom, Math.max(2, t.r*0.12*camera.zoom), 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(s.x - t.r*0.2*camera.zoom, s.y - t.r*0.25*camera.zoom, Math.max(1, t.r*0.05*camera.zoom), 0, Math.PI*2); ctx.fill(); }
  const sp = worldToScreen(player.x, player.y); ctx.beginPath(); ctx.fillStyle = player.color; ctx.ellipse(sp.x, sp.y, player.r*1.2*camera.zoom, player.r*0.9*camera.zoom, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(sp.x - player.r*0.18*camera.zoom, sp.y - player.r*0.22*camera.zoom, Math.max(2, player.r*0.1*camera.zoom), 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(sp.x - player.r*0.18*camera.zoom, sp.y - player.r*0.22*camera.zoom, Math.max(1, player.r*0.05*camera.zoom), 0, Math.PI*2); ctx.fill();
}

/* HUD & Game Over */
function updateHUD(){ document.getElementById('score').innerText = score; document.getElementById('size').innerText = Math.round(player.mass); document.getElementById('ghostsCount').innerText = trouts.length; }
function gameOver(reason){ running=false; document.getElementById('msgTitle').innerText='Has muerto'; document.getElementById('msgBody').innerText = reason + '. Puntaje: ' + score; document.getElementById('message').style.display = 'flex'; }

/* Loop */
function frameLoop(now){ const dt = Math.min(0.06, (now - lastTime)/1000); lastTime = now; update(dt); draw(); requestAnimationFrame(frameLoop); }

/* Buttons */
document.getElementById('btnStart').addEventListener('click', ()=>{ initGame(); lastTime = performance.now(); requestAnimationFrame(frameLoop); });
document.getElementById('btnPause').addEventListener('click', ()=>{ paused = !paused; document.getElementById('btnPause').innerText = paused ? 'Reanudar' : 'Pausa'; });
document.getElementById('btnReset').addEventListener('click', ()=>{ initGame(); });
document.getElementById('respawn').addEventListener('click', ()=>{ document.getElementById('message').style.display='none'; initGame(); });

/* start but don't auto-run (user clicks Iniciar) */
(function start(){
  camera.zoom = Math.min(1, Math.max(0.6, W / 1000));
  initGame();
  running = false; // wait for user click
})();
</script>
</body>
</html>


