<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PAC-Fish — Arreglado (colisiones, spawn, pantalla)</title>
  <style>
    :root { --ui-padding:18px; --bg1:#f6fbfd; --bg2:#eef7fa; }
    html,body { height:100%; margin:0; }
    body { background: linear-gradient(180deg,var(--bg1),var(--bg2)); font-family: Arial, Helvetica, sans-serif; display:flex; align-items:center; justify-content:center; padding:var(--ui-padding); box-sizing:border-box; }
    .wrap { width:100%; max-width:1400px; text-align:center; }
    h1 { margin:0 0 8px 0; }
    .info { margin:8px 0 12px 0; color:#222; }
    #pf-canvas { border-radius:12px; background:#00131a; display:block; margin:0 auto; box-shadow:0 10px 30px rgba(0,0,0,0.18); }
    .controls { margin-top:12px; }
    .hide-badge { display:inline-block; padding:6px 10px; border-radius:16px; background:#2f8f66; color:#fff; font-size:0.85rem; margin-left:8px }
    button{ padding:8px 12px; margin:0 6px; cursor:pointer; }
    @media (max-width:720px){
      .wrap { padding-bottom:10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PAC-Fish (Correcciones: colisión / spawn / pantalla)</h1>

    <div style="margin-bottom:8px;">
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="orestia" checked> Orestia</label>
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="sardina"> Sardina</label>
      <label><input type="radio" name="pf-character" value="bagre"> Bagre</label>
    </div>

    <div class="info">
      Nivel: <span id="pf-level">1</span> · Vidas: <span id="pf-lives">3</span> · Puntos: <span id="pf-score">0</span>
      <span id="hide-indicator" class="hide-badge" style="display:none">En escondite</span>
      · Pellets: <span id="pf-pellets">0</span> · Peces nativos: <span id="pf-natives">0</span>
    </div>

    <canvas id="pf-canvas"></canvas>

    <div class="controls">
      <button id="pf-start">Iniciar / Reiniciar</button>
      <button id="pf-pause">Pausa</button>
    </div>

    <p style="margin-top:12px; color:#666; font-size:0.95rem;">El canvas es responsivo y se adapta a la pantalla. Usa ←→↑↓ o WASD. Power-ups: caracoles/hyalellas (velocidad).</p>
  </div>

<script>
/* PAC-Fish - Versión corregida
   - Colisiones por área (no solo tile)
   - Spawn inicial de truchas separado
   - Evitar scroll del navegador con flechas/WASD
   - Canvas responsivo que ocupa buena parte de la pantalla
*/

// Configuración (puedes modificar)
const PF_CONFIG = {
  cols: 22,
  rows: 22,
  initialLives: 3,
  maxLevel: 30,
  nativeCount: 4,
  powerupCount: 4,
  minGhostSpawnDistFromPlayer: 4.0, // separación mínima al inicio (tiles)
  minGhostSpawnDistBetween: 2.4     // separación mínima entre fantasmas
};

// valores mutables para tamaño del tile/canvas (se calculan en resize)
let TILE = 28;
let WIDTH = PF_CONFIG.cols * TILE;
let HEIGHT = PF_CONFIG.rows * TILE;

function resizeCanvasToScreen() {
  // dejar márgenes UI y calcular tile para que el canvas quepa en pantalla
  const marginX = 60, marginY = 160;
  const availW = Math.max(300, window.innerWidth - marginX);
  const availH = Math.max(300, window.innerHeight - marginY);
  const maxSize = Math.min(availW, availH);
  // tile tamaño según la mayor dimensión entre cols/rows para aprovechar el cuadrado
  TILE = Math.floor(maxSize / Math.max(PF_CONFIG.cols, PF_CONFIG.rows));
  if (TILE < 14) TILE = 14; // mínimo legible
  WIDTH = PF_CONFIG.cols * TILE;
  HEIGHT = PF_CONFIG.rows * TILE;
  canvas.width = WIDTH; canvas.height = HEIGHT;
}

const canvas = document.getElementById('pf-canvas');
const ctx = canvas.getContext('2d');
resizeCanvasToScreen();
window.addEventListener('resize', ()=>{ resizeCanvasToScreen(); draw(); });

// Map generator y tiles:
// 0 empty, 1 wall, 2 pellet, 3 hide, 4 power-up
function generateMap(cols, rows) {
  const map = Array(rows).fill().map(()=>Array(cols).fill(2));
  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++){
    if (r===0||c===0||r===rows-1||c===cols-1) map[r][c]=1;
  }
  // obstáculos internos (simétricos)
  const blocks = [
    {r:3,c:3,h:3,w:3}, {r:3,c:cols-6,h:3,w:3},
    {r:rows-6,c:3,h:3,w:3}, {r:rows-6,c:cols-6,h:3,w:3},
    {r:Math.floor(rows/2)-1,c:Math.floor(cols/2)-3,h:3,w:6}
  ];
  blocks.forEach(b=>{
    for(let rr=0; rr<b.h; rr++) for(let cc=0; cc<b.w; cc++){
      const r=b.r+rr, c=b.c+cc;
      if (r>0 && c>0 && r<rows-1 && c<cols-1) map[r][c]=1;
    }
  });
  // escondites 2x2 en esquinas
  const corners = [ {r:1,c:1}, {r:1,c:cols-3}, {r:rows-3,c:1}, {r:rows-3,c:cols-3} ];
  corners.forEach(pt => {
    for (let dr=0; dr<2; dr++) for (let dc=0; dc<2; dc++){
      const rr = pt.r+dr, cc = pt.c+dc;
      if (rr>0 && cc>0 && rr<rows-1 && cc<cols-1) map[rr][cc] = 3;
    }
  });
  map.__hideCenters = corners.map(pt => ({r: pt.r, c: pt.c}));
  // limpiar spawn central 3x3
  const cx = Math.floor(cols/2), cy = Math.floor(rows/2);
  for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
    if (cy+dr>0 && cx+dc>0 && cy+dr<rows-1 && cx+dc<cols-1) map[cy+dr][cx+dc] = 0;
  }
  // colocar powerups
  map.__powerups = [];
  let attempts = 0;
  while(map.__powerups.length < PF_CONFIG.powerupCount && attempts < 500){
    attempts++;
    const r = 2 + Math.floor(Math.random()*(rows-4));
    const c = 2 + Math.floor(Math.random()*(cols-4));
    if (map[r][c] === 2) { map[r][c] = 4; map.__powerups.push({r,c}); }
  }
  return map;
}

/* Entidades */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
class Entity { constructor(x,y){ this.x=x; this.y=y; this.dir={x:0,y:0}; } }
class Player extends Entity {
  constructor(x,y){ super(x,y); this.nextDir={x:0,y:0}; this.hidden=false; this.hideExpires=0; this.hideCooldowns=[0,0,0,0]; this.speedBoostExpires=0; this.baseSpeed=4.0; }
  getSpeed(now){ return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed; }
}
class Ghost extends Entity {
  constructor(x,y,color){ super(x,y); this.color=color||'#f55'; this.speed=3.6; this.dir={x:0,y:0}; }
}
class NativeFish extends Entity {
  constructor(x,y){ super(x,y); this.baseSpeed=2.2; this.speedBoostExpires=0; this.dir={x:0,y:0}; }
  getSpeed(now){ return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed; }
}

/* Variables globales del juego */
let map = generateMap(PF_CONFIG.cols, PF_CONFIG.rows);
let player, ghosts = [], natives = [], score=0, lives=PF_CONFIG.initialLives, level=1, pelletsRemaining=0;
let running=false, paused=false, lastTime=performance.now();

/* --- Mejora de colisión: comprobar el área (círculo) del jugador/entidad ---
   En lugar de usar floor(x), floor(y) únicamente, verificamos todas las tiles
   potenciales que intersecta la "cola/cuerpo" del pez según un radio.
*/
function collidesWithWallAt(x, y, radiusTiles=0.44) {
  // calcula tile range
  const minC = Math.floor(x - radiusTiles), maxC = Math.floor(x + radiusTiles);
  const minR = Math.floor(y - radiusTiles), maxR = Math.floor(y + radiusTiles);
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      if (r < 0 || c < 0 || r >= PF_CONFIG.rows || c >= PF_CONFIG.cols) return true;
      if (map[r][c] === 1) {
        // opción conservadora: si cualquier tile del bounding box es pared, colisionamos
        return true;
      }
    }
  }
  return false;
}

/* Intento de mover entidad: si movimiento completo falla, intenta mover por ejes
   (esto evita quedar atascado en esquinas porque desliza por un eje libre)
*/
function tryMoveEntity(entity, dx, dy, speed, delta) {
  const nx = entity.x + dx * speed * (delta/1000);
  const ny = entity.y + dy * speed * (delta/1000);
  if (!collidesWithWallAt(nx, ny)) { entity.x = nx; entity.y = ny; return true; }

  // intentar mover solo X
  if (dx !== 0) {
    const nxOnly = entity.x + dx * speed * (delta/1000);
    if (!collidesWithWallAt(nxOnly, entity.y)) { entity.x = nxOnly; return true; }
  }
  // intentar mover solo Y
  if (dy !== 0) {
    const nyOnly = entity.y + dy * speed * (delta/1000);
    if (!collidesWithWallAt(entity.x, nyOnly)) { entity.y = nyOnly; return true; }
  }
  return false;
}

/* --- Spawn inicial de fantasmas separado ---
   Genera posiciones alrededor del centro pero garantiza distancia mínima al jugador
   y distancia mínima entre fantasmas.
*/
function spawnGhostsForLevel(levelIndex) {
  ghosts = [];
  const baseGhosts = Math.min(10, Math.floor(2 + levelIndex * 0.7));
  const centerX = PF_CONFIG.cols/2, centerY = PF_CONFIG.rows/2;
  const radius = 4.0 + Math.min(5, Math.floor(levelIndex/4)); // radio de spawn
  const triesLimit = 400;

  for (let i=0; i<baseGhosts; i++){
    let placed=false, tries=0;
    while(!placed && tries < triesLimit){
      tries++;
      // intenta distribuir por ángulos aleatorios en el círculo de spawn
      const angle = Math.random() * Math.PI * 2;
      const gx = Math.floor(centerX + Math.cos(angle) * radius) + 0.5;
      const gy = Math.floor(centerY + Math.sin(angle) * radius) + 0.5;
      const distToPlayer = Math.hypot(gx - (PF_CONFIG.cols/2 + 0.5), gy - (PF_CONFIG.rows/2 + 0.5));
      if (distToPlayer < PF_CONFIG.minGhostSpawnDistFromPlayer) continue;

      // comprobar distancia a otros ghosts ya colocados
      let ok=true;
      for (let g of ghosts) {
        if (Math.hypot(g.x - gx, g.y - gy) < PF_CONFIG.minGhostSpawnDistBetween) { ok=false; break; }
      }
      if (!ok) continue;

      // comprobar que la posición no está dentro de pared
      if (collidesWithWallAt(gx, gy)) continue;

      // colocar
      const color = '#'+(Math.floor(Math.random()*16777215).toString(16)).padStart(6,'0');
      const gg = new Ghost(gx, gy, color);
      gg.speed = Math.min(5.2, 2.8 + levelIndex * 0.18 + Math.random()*0.6);
      ghosts.push(gg); placed=true;
    }
    if (!placed) {
      // fallback: colocar cerca del centro sin garantizar separación
      const fallback = new Ghost(centerX + 2 + i*0.2, centerY + 2 + i*0.2, '#ff5555');
      fallback.speed = Math.min(5.2, 3.0 + Math.random()*0.4);
      ghosts.push(fallback);
    }
  }
}

/* Nativos */
function spawnNatives() {
  natives = [];
  for (let i=0;i<PF_CONFIG.nativeCount;i++){
    const gx = Math.floor(PF_CONFIG.cols/2 + (i%2? -5:5) + (Math.random()*2-1)) + 0.5;
    const gy = Math.floor(PF_CONFIG.rows/2 + (i<2? -3:3) + (Math.random()*2-1)) + 0.5;
    if (!collidesWithWallAt(gx, gy)) natives.push(new NativeFish(gx, gy));
  }
}

/* Contabilizar pellets */
function countPellets() {
  let c=0;
  for (let r=0;r<PF_CONFIG.rows;r++) for (let c2=0;c2<PF_CONFIG.cols;c2++) if (map[r][c2]===2) c++;
  return c;
}

/* iniciar nivel */
function startLevel(l) {
  map = generateMap(PF_CONFIG.cols, PF_CONFIG.rows);
  // ubicar player en centro del mapa
  player = new Player(Math.floor(PF_CONFIG.cols/2)+0.5, Math.floor(PF_CONFIG.rows/2)+0.5);
  player.dir={x:0,y:0}; player.nextDir={x:0,y:0}; player.hidden=false; player.hideExpires=0; player.speedBoostExpires=0; player.hideCooldowns=[0,0,0,0];

  spawnGhostsForLevel(l);
  spawnNatives();

  pelletsRemaining = countPellets();
  running = true; paused = false;
  updateHUD();
}

/* Drawing */
function draw() {
  // ajustar canvas por si resize cambió TILE
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';

  // fondo
  ctx.fillStyle = '#00131a';
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // tiles
  for (let r=0;r<PF_CONFIG.rows;r++){
    for (let c=0;c<PF_CONFIG.cols;c++){
      const x = c*TILE, y = r*TILE;
      if (map[r][c]===1) {
        ctx.fillStyle = '#133';
        ctx.fillRect(x,y,TILE,TILE);
      } else if (map[r][c]===2) {
        ctx.fillStyle = '#ffd54f';
        const cx = x + TILE/2, cy = y + TILE/2;
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(2, TILE*0.08), 0, Math.PI*2); ctx.fill();
      } else if (map[r][c]===3) {
        ctx.fillStyle = '#093'; ctx.fillRect(x+2, y+2, TILE-4, TILE-4);
      } else if (map[r][c]===4) {
        const cx = x + TILE/2, cy = y + TILE/2;
        ctx.fillStyle = '#8be04f'; ctx.beginPath(); ctx.arc(cx, cy, TILE*0.18, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#2b5e2b'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, TILE*0.28, Math.PI*0.4, Math.PI*1.2); ctx.stroke();
      }
    }
  }

  // player
  const px = player.x * TILE, py = player.y * TILE;
  ctx.save(); ctx.translate(px + TILE/2, py + TILE/2);
  const sel = document.querySelector('input[name="pf-character"]:checked').value;
  let pColor = '#FFD700';
  if (sel === 'sardina') pColor = '#6ECFF6';
  if (sel === 'bagre') pColor = '#A07C4A';
  if (player.hidden) {
    ctx.beginPath(); ctx.arc(0,0,TILE*0.7,0,Math.PI*2); ctx.fillStyle='rgba(46,204,113,0.14)'; ctx.fill();
    ctx.strokeStyle='rgba(46,204,113,0.28)'; ctx.lineWidth=2; ctx.stroke();
  }
  ctx.fillStyle = pColor; ctx.beginPath(); ctx.arc(0,0, TILE*0.42, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // natives
  natives.forEach(n=>{
    const gx = n.x*TILE + TILE/2, gy = n.y*TILE + TILE/2;
    ctx.fillStyle = '#9ae0ff'; ctx.beginPath(); ctx.ellipse(gx, gy, TILE*0.36, TILE*0.22, 0, 0, Math.PI*2); ctx.fill();
    if (Date.now() < n.speedBoostExpires) {
      ctx.strokeStyle = 'rgba(138,224,255,0.45)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(gx, gy, TILE*0.48, 0, Math.PI*2); ctx.stroke();
    }
  });

  // ghosts
  ghosts.forEach(g => {
    const gx = g.x*TILE + TILE/2, gy = g.y*TILE + TILE/2;
    ctx.fillStyle = g.color; ctx.beginPath(); ctx.ellipse(gx, gy, TILE*0.46, TILE*0.36, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(gx - TILE*0.12, gy - TILE*0.05, TILE*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + TILE*0.12, gy - TILE*0.05, TILE*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(gx - TILE*0.12, gy - TILE*0.05, TILE*0.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + TILE*0.12, gy - TILE*0.05, TILE*0.05, 0, Math.PI*2); ctx.fill();
  });
}

/* --- Update física/IA --- */
function update(delta) {
  if (!running || paused) return;
  const now = Date.now();

  // esconderse expirado
  if (player.hidden && now > player.hideExpires) {
    player.hidden = false; document.getElementById('hide-indicator').style.display = 'none';
  }

  // cambiar dir si nextDir valido
  if (player.nextDir.x !== 0 || player.nextDir.y !== 0) {
    const testX = player.x + player.nextDir.x * 0.25, testY = player.y + player.nextDir.y * 0.25;
    if (!collidesWithWallAt(testX, testY)) player.dir = {...player.nextDir};
  }

  // mover player con colisión sólida por área y deslizamiento
  const pSpeed = player.getSpeed(now);
  tryMoveEntity(player, player.dir.x, player.dir.y, pSpeed, delta);
  player.x = clamp(player.x, 0.12, PF_CONFIG.cols - 0.12);
  player.y = clamp(player.y, 0.12, PF_CONFIG.rows - 0.12);

  // interacción con tiles
  const pr = Math.floor(player.y), pc = Math.floor(player.x);
  if (map[pr][pc] === 2) {
    map[pr][pc] = 0; pelletsRemaining--; score += 10; updateHUD();
    if (pelletsRemaining <= 0) {
      level++;
      if (level > PF_CONFIG.maxLevel) { alert('¡Felicidades! completaste todos los niveles.'); resetGame(); return; }
      else { startLevel(level); return; }
    }
  } else if (map[pr][pc] === 3) {
    const centers = map.__hideCenters; let cornerIndex=-1;
    centers.forEach((cpt, idx) => { if (Math.abs(pr - cpt.r) <=1 && Math.abs(pc - cpt.c) <=1) cornerIndex = idx; });
    if (cornerIndex >= 0) {
      const nowms = Date.now();
      if (nowms > player.hideCooldowns[cornerIndex]) {
        player.hidden = true; player.hideExpires = nowms + 5000; player.hideCooldowns[cornerIndex] = nowms + 15000;
        document.getElementById('hide-indicator').style.display = 'inline-block';
      }
    }
  } else if (map[pr][pc] === 4) {
    map[pr][pc] = 0; player.speedBoostExpires = Date.now() + 7000; score += 30; updateHUD();
  }

  // natives: comportamiento y consumo de pellets/powerups
  natives.forEach(n => {
    const nowMs = Date.now();
    if (Math.random() < 0.14) {
      // buscar pellet cercano
      let target=null, bestD=999;
      for (let r = Math.max(1, Math.floor(n.y)-5); r <= Math.min(PF_CONFIG.rows-2, Math.floor(n.y)+5); r++){
        for (let c = Math.max(1, Math.floor(n.x)-5); c <= Math.min(PF_CONFIG.cols-2, Math.floor(n.x)+5); c++){
          if (map[r][c] === 2) {
            const dx = (c+0.5) - n.x, dy = (r+0.5) - n.y; const d = Math.hypot(dx,dy);
            if (d < bestD) { bestD = d; target = {dx: dx/d, dy: dy/d}; }
          }
        }
      }
      if (target) n.dir = {x: Math.sign(target.dx), y: Math.sign(target.dy)};
      else {
        const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        n.dir = dirs[Math.floor(Math.random()*dirs.length)];
      }
    }

    tryMoveEntity(n, n.dir.x, n.dir.y, n.getSpeed(nowMs), delta);

    const nr = Math.floor(n.y), nc = Math.floor(n.x);
    if (map[nr][nc] === 2) { map[nr][nc] = 0; pelletsRemaining--; score += 2; if (pelletsRemaining <= 0){ level++; if (level>PF_CONFIG.maxLevel){ alert('¡Felicidades! completaste todos los niveles.'); resetGame(); return; } else { startLevel(level); return; } } }
    else if (map[nr][nc] === 4) { map[nr][nc] = 0; n.speedBoostExpires = Date.now() + 7000; }
  });

  // ghosts: IA (persecución cuando cerca) y colisiones por área
  ghosts.forEach(g => {
    const dx = player.x - g.x, dy = player.y - g.y;
    const dist = Math.hypot(dx,dy);
    let targetDir = {x:0,y:0};
    if (!player.hidden && dist < Math.max(7, 8 - Math.min(3, level*0.06))) {
      if (Math.abs(dx) > Math.abs(dy)) targetDir.x = dx > 0 ? 1 : -1;
      else targetDir.y = dy > 0 ? 1 : -1;
    } else {
      const cx = PF_CONFIG.cols/2 - 1, cy = PF_CONFIG.rows/2 - 1;
      const cdx = cx - g.x, cdy = cy - g.y;
      if (Math.random() < 0.5) {
        if (Math.abs(cdx) > Math.abs(cdy)) targetDir.x = cdx>0?1:-1; else targetDir.y = cdy>0?1:-1;
      } else {
        if (Math.random() < 0.18 + level*0.01) {
          const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
          targetDir = dirs[Math.floor(Math.random()*dirs.length)];
        } else targetDir = g.dir || {x:0,y:0};
      }
    }

    tryMoveEntity(g, targetDir.x, targetDir.y, g.speed, delta);
    g.dir = targetDir;

    // colisión con jugador
    const ddx = player.x - g.x, ddy = player.y - g.y;
    if (!player.hidden && Math.hypot(ddx, ddy) < 0.6) {
      lives--; updateHUD();
      if (lives <= 0) { alert('Juego terminado. Reiniciando...'); resetGame(); }
      else { startLevel(level); }
    }
  });

  updateHUD();
}

/* HUD y controles */
function updateHUD(){
  document.getElementById('pf-level').innerText = level;
  document.getElementById('pf-lives').innerText = lives;
  document.getElementById('pf-score').innerText = score;
  document.getElementById('pf-pellets').innerText = pelletsRemaining;
  document.getElementById('pf-natives').innerText = natives.length;
}

/* Input: evitar scroll de la página con flechas/WASD */
window.addEventListener('keydown', function(e){
  const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
  if (keys.includes(e.key)) {
    e.preventDefault(); // evita desplazamiento de la página
  }
  if(!player) return;
  if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') player.nextDir={x:0,y:-1};
  if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') player.nextDir={x:0,y:1};
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') player.nextDir={x:-1,y:0};
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') player.nextDir={x:1,y:0};
});

/* Loop principal */
function loop(now) {
  const delta = now - lastTime;
  lastTime = now;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

/* Botones */
document.getElementById('pf-start').addEventListener('click', ()=>{
  resetGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);
});
document.getElementById('pf-pause').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('pf-pause').innerText = paused ? 'Reanudar' : 'Pausa';
});

/* Reset y init */
function resetGame(){ level=1; lives=PF_CONFIG.initialLives; score=0; startLevel(level); updateHUD(); }

(function init(){
  // recalcular tamaño inicial (por si dispositivo cambió)
  resizeCanvasToScreen();
  startLevel(1);
  updateHUD();
})();
</script>
</body>
</html>


