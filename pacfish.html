<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PAC-Fish — Refactorizado (Lógica Mejorada)</title>
  <style>
    :root { --ui-padding:18px; --bg1:#f6fbfd; --bg2:#eef7fa; }
    html,body { height:100%; margin:0; }
    body { background: linear-gradient(180deg,var(--bg1),var(--bg2)); font-family: Arial, Helvetica, sans-serif; display:flex; align-items:center; justify-content:center; padding:var(--ui-padding); box-sizing:border-box; }
    .wrap { width:100%; max-width:1400px; text-align:center; }
    h1 { margin:0 0 8px 0; }
    .info { margin:8px 0 12px 0; color:#222; }
    #pf-canvas { border-radius:12px; background:#00131a; display:block; margin:0 auto; box-shadow:0 10px 30px rgba(0,0,0,0.18); }
    .controls { margin-top:12px; }
    .hide-badge { display:inline-block; padding:6px 10px; border-radius:16px; background:#2f8f66; color:#fff; font-size:0.85rem; margin-left:8px }
    button{ padding:8px 12px; margin:0 6px; cursor:pointer; }
    @media (max-width:720px){
      .wrap { padding-bottom:10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PAC-Fish (Refactorizado — Lógica Mejorada)</h1>

    <div style="margin-bottom:8px;">
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="orestia" checked> Orestia</label>
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="sardina"> Sardina</label>
      <label><input type="radio" name="pf-character" value="bagre"> Bagre</label>
    </div>

    <div class="info">
      Nivel: <span id="pf-level">1</span> · Vidas: <span id="pf-lives">3</span> · Puntos: <span id="pf-score">0</span>
      <span id="hide-indicator" class="hide-badge" style="display:none">En escondite</span>
      · Pellets: <span id="pf-pellets">0</span> · Peces nativos: <span id="pf-natives">0</span>
    </div>

    <canvas id="pf-canvas"></canvas>

    <div class="controls">
      <button id="pf-start">Iniciar / Reiniciar</button>
      <button id="pf-pause">Pausa</button>
    </div>

    <p style="margin-top:12px; color:#666; font-size:0.95rem;">El canvas es responsivo y se adapta a la pantalla. Usa ←→↑↓ o WASD. Power-ups: caracoles/hyalellas (velocidad).</p>
  </div>

<script>
// ============= CONFIGURACIÓN =============
const CONFIG = {
  cols: 22,
  rows: 22,
  initialLives: 3,
  maxLevel: 30,
  nativeCount: 4,
  powerupCount: 4,
  minGhostSpawnDistFromPlayer: 4.0,
  minGhostSpawnDistBetween: 2.4,
  playerRadius: 0.44,
  collisionRadius: 0.44
};

// ============= ESTADO DEL JUEGO =============
const gameState = {
  running: false,
  paused: false,
  level: 1,
  lives: CONFIG.initialLives,
  score: 0,
  pelletsRemaining: 0,
  lastTime: 0,
  map: null,
  player: null,
  ghosts: [],
  natives: [],
  canvas: null,
  ctx: null,
  tile: 28,
  width: 0,
  height: 0
};

// ============= UTILIDADES =============
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function distance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function randomColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }

// ============= CLASES =============

class Entity {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.dir = { x: 0, y: 0 };
  }

  // Método genérico para dibujarse (sobrescribir en subclases)
  draw(ctx, tile) {}

  // Comportamiento genérico de movimiento con colisión
  tryMove(map, speed, delta) {
    const nx = this.x + this.dir.x * speed * (delta / 1000);
    const ny = this.y + this.dir.y * speed * (delta / 1000);

    if (!this.collidesWithWall(map, nx, ny)) {
      this.x = nx;
      this.y = ny;
      return true;
    }

    // Intentar mover solo en X
    if (this.dir.x !== 0) {
      const nxOnly = this.x + this.dir.x * speed * (delta / 1000);
      if (!this.collidesWithWall(map, nxOnly, this.y)) {
        this.x = nxOnly;
        return true;
      }
    }

    // Intentar mover solo en Y
    if (this.dir.y !== 0) {
      const nyOnly = this.y + this.dir.y * speed * (delta / 1000);
      if (!this.collidesWithWall(map, this.x, nyOnly)) {
        this.y = nyOnly;
        return true;
      }
    }

    return false;
  }

  collidesWithWall(map, x, y) {
    const radius = CONFIG.collisionRadius;
    const minC = Math.floor(x - radius);
    const maxC = Math.floor(x + radius);
    const minR = Math.floor(y - radius);
    const maxR = Math.floor(y + radius);

    for (let r = minR; r <= maxR; r++) {
      for (let c = minC; c <= maxC; c++) {
        if (r < 0 || c < 0 || r >= CONFIG.rows || c >= CONFIG.cols) return true;
        if (map[r][c] === 1) return true;
      }
    }
    return false;
  }
}

class Player extends Entity {
  constructor(x, y) {
    super(x, y);
    this.nextDir = { x: 0, y: 0 };
    this.hidden = false;
    this.hideExpires = 0;
    this.hideCooldowns = [0, 0, 0, 0];
    this.speedBoostExpires = 0;
    this.baseSpeed = 4.0;
  }

  getSpeed(now) {
    return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed;
  }

  draw(ctx, tile) {
    const px = this.x * tile;
    const py = this.y * tile;

    ctx.save();
    ctx.translate(px + tile / 2, py + tile / 2);

    const sel = document.querySelector('input[name="pf-character"]:checked').value;
    let color = '#FFD700';
    if (sel === 'sardina') color = '#6ECFF6';
    if (sel === 'bagre') color = '#A07C4A';

    if (this.hidden) {
      ctx.beginPath();
      ctx.arc(0, 0, tile * 0.7, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(46,204,113,0.14)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(46,204,113,0.28)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, tile * 0.42, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  collectItem(map, r, c) {
    if (map[r][c] === 2) {
      map[r][c] = 0;
      gameState.pelletsRemaining--;
      gameState.score += 10;
      return true;
    } else if (map[r][c] === 3) {
      const centers = map.__hideCenters;
      let cornerIndex = -1;
      centers.forEach((cpt, idx) => {
        if (Math.abs(r - cpt.r) <= 1 && Math.abs(c - cpt.c) <= 1) cornerIndex = idx;
      });
      if (cornerIndex >= 0) {
        const now = performance.now();
        if (now > this.hideCooldowns[cornerIndex]) {
          this.hidden = true;
          this.hideExpires = now + 5000;
          this.hideCooldowns[cornerIndex] = now + 15000;
          document.getElementById('hide-indicator').style.display = 'inline-block';
        }
      }
      return true;
    } else if (map[r][c] === 4) {
      map[r][c] = 0;
      this.speedBoostExpires = performance.now() + 7000;
      gameState.score += 30;
      return true;
    }
    return false;
  }
}

class Ghost extends Entity {
  constructor(x, y, color) {
    super(x, y);
    this.color = color || '#f55';
    this.speed = 3.6;
  }

  draw(ctx, tile) {
    const gx = this.x * tile + tile / 2;
    const gy = this.y * tile + tile / 2;

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.ellipse(gx, gy, tile * 0.46, tile * 0.36, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(gx - tile * 0.12, gy - tile * 0.05, tile * 0.12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(gx + tile * 0.12, gy - tile * 0.05, tile * 0.12, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(gx - tile * 0.12, gy - tile * 0.05, tile * 0.05, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(gx + tile * 0.12, gy - tile * 0.05, tile * 0.05, 0, Math.PI * 2);
    ctx.fill();
  }

  updateAI(player, level) {
    const dx = player.x - this.x;
    const dy = player.y - this.y;
    const dist = distance(this.x, this.y, player.x, player.y);

    if (!player.hidden && dist < Math.max(7, 8 - Math.min(3, level * 0.06))) {
      if (Math.abs(dx) > Math.abs(dy)) {
        this.dir.x = dx > 0 ? 1 : -1;
        this.dir.y = 0;
      } else {
        this.dir.x = 0;
        this.dir.y = dy > 0 ? 1 : -1;
      }
    } else {
      const cx = CONFIG.cols / 2 - 1;
      const cy = CONFIG.rows / 2 - 1;
      const cdx = cx - this.x;
      const cdy = cy - this.y;

      if (Math.random() < 0.5) {
        if (Math.abs(cdx) > Math.abs(cdy)) {
          this.dir.x = cdx > 0 ? 1 : -1;
          this.dir.y = 0;
        } else {
          this.dir.x = 0;
          this.dir.y = cdy > 0 ? 1 : -1;
        }
      } else {
        if (Math.random() < 0.18 + level * 0.01) {
          const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
          this.dir = dirs[Math.floor(Math.random() * dirs.length)];
        }
      }
    }
  }

  checkCollision(player) {
    if (!player.hidden && distance(this.x, this.y, player.x, player.y) < 0.6) {
      gameState.lives--;
      updateHUD();
      if (gameState.lives <= 0) {
        alert('Juego terminado. Reiniciando...');
        resetGame();
        return true;
      } else {
        startLevel(gameState.level);
        return true;
      }
    }
    return false;
  }
}

class NativeFish extends Entity {
  constructor(x, y) {
    super(x, y);
    this.baseSpeed = 2.2;
    this.speedBoostExpires = 0;
  }

  getSpeed(now) {
    return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed;
  }

  draw(ctx, tile) {
    const gx = this.x * tile + tile / 2;
    const gy = this.y * tile + tile / 2;

    ctx.fillStyle = '#9ae0ff';
    ctx.beginPath();
    ctx.ellipse(gx, gy, tile * 0.36, tile * 0.22, 0, 0, Math.PI * 2);
    ctx.fill();

    if (performance.now() < this.speedBoostExpires) {
      ctx.strokeStyle = 'rgba(138,224,255,0.45)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(gx, gy, tile * 0.48, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  updateAI(map) {
    if (Math.random() < 0.14) {
      let target = null;
      let bestD = 999;

      for (let r = Math.max(1, Math.floor(this.y) - 5); r <= Math.min(CONFIG.rows - 2, Math.floor(this.y) + 5); r++) {
        for (let c = Math.max(1, Math.floor(this.x) - 5); c <= Math.min(CONFIG.cols - 2, Math.floor(this.x) + 5); c++) {
          if (map[r][c] === 2) {
            const dx = (c + 0.5) - this.x;
            const dy = (r + 0.5) - this.y;
            const d = distance(0, 0, dx, dy);
            if (d < bestD) {
              bestD = d;
              target = { x: Math.sign(dx), y: Math.sign(dy) };
            }
          }
        }
      }

      if (target) {
        this.dir = target;
      } else {
        const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
        this.dir = dirs[Math.floor(Math.random() * dirs.length)];
      }
    }
  }

  collectItem(map, r, c) {
    if (map[r][c] === 2) {
      map[r][c] = 0;
      gameState.pelletsRemaining--;
      gameState.score += 2;
      return true;
    } else if (map[r][c] === 4) {
      map[r][c] = 0;
      this.speedBoostExpires = performance.now() + 7000;
      return true;
    }
    return false;
  }
}

// ============= MAPA =============
function generateMap(cols, rows) {
  const map = Array(rows).fill().map(() => Array(cols).fill(2));

  // Bordes
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (r === 0 || c === 0 || r === rows - 1 || c === cols - 1) map[r][c] = 1;
    }
  }

  // Obstáculos internos
  const blocks = [
    {r:3,c:3,h:3,w:3}, {r:3,c:cols-6,h:3,w:3},
    {r:rows-6,c:3,h:3,w:3}, {r:rows-6,c:cols-6,h:3,w:3},
    {r:Math.floor(rows/2)-1,c:Math.floor(cols/2)-3,h:3,w:6}
  ];

  blocks.forEach(b => {
    for (let rr = 0; rr < b.h; rr++) {
      for (let cc = 0; cc < b.w; cc++) {
        const r = b.r + rr;
        const c = b.c + cc;
        if (r > 0 && c > 0 && r < rows - 1 && c < cols - 1) map[r][c] = 1;
      }
    }
  });

  // Escondites
  const corners = [ {r:1,c:1}, {r:1,c:cols-3}, {r:rows-3,c:1}, {r:rows-3,c:cols-3} ];
  corners.forEach(pt => {
    for (let dr = 0; dr < 2; dr++) {
      for (let dc = 0; dc < 2; dc++) {
        const rr = pt.r + dr;
        const cc = pt.c + dc;
        if (rr > 0 && cc > 0 && rr < rows - 1 && cc < cols - 1) map[rr][cc] = 3;
      }
    }
  });
  map.__hideCenters = corners;

  // Spawn central limpio
  const cx = Math.floor(cols / 2);
  const cy = Math.floor(rows / 2);
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const r = cy + dr;
      const c = cx + dc;
      if (r > 0 && c > 0 && r < rows - 1 && c < cols - 1) map[r][c] = 0;
    }
  }

  // Power-ups
  map.__powerups = [];
  let attempts = 0;
  while (map.__powerups.length < CONFIG.powerupCount && attempts < 500) {
    attempts++;
    const r = 2 + Math.floor(Math.random() * (rows - 4));
    const c = 2 + Math.floor(Math.random() * (cols - 4));
    if (map[r][c] === 2) {
      map[r][c] = 4;
      map.__powerups.push({r, c});
    }
  }

  return map;
}

function countPellets(map) {
  let count = 0;
  for (let r = 0; r < CONFIG.rows; r++) {
    for (let c = 0; c < CONFIG.cols; c++) {
      if (map[r][c] === 2) count++;
    }
  }
  return count;
}

// ============= SPAWN =============
function spawnGhosts(level) {
  const ghosts = [];
  const baseGhosts = Math.min(10, Math.floor(2 + level * 0.7));
  const centerX = CONFIG.cols / 2;
  const centerY = CONFIG.rows / 2;
  const radius = 4.0 + Math.min(5, Math.floor(level / 4));
  const triesLimit = 400;

  for (let i = 0; i < baseGhosts; i++) {
    let placed = false;
    let tries = 0;

    while (!placed && tries < triesLimit) {
      tries++;
      const angle = Math.random() * Math.PI * 2;
      const gx = Math.floor(centerX + Math.cos(angle) * radius) + 0.5;
      const gy = Math.floor(centerY + Math.sin(angle) * radius) + 0.5;

      if (distance(gx, gy, centerX + 0.5, centerY + 0.5) < CONFIG.minGhostSpawnDistFromPlayer) continue;

      let tooClose = false;
      for (const ghost of ghosts) {
        if (distance(ghost.x, ghost.y, gx, gy) < CONFIG.minGhostSpawnDistBetween) {
          tooClose = true;
          break;
        }
      }
      if (tooClose) continue;

      if (collidesWithWallAt(gameState.map, gx, gy)) continue;

      const ghost = new Ghost(gx, gy, randomColor());
      ghost.speed = Math.min(5.2, 2.8 + level * 0.18 + Math.random() * 0.6);
      ghosts.push(ghost);
      placed = true;
    }

    if (!placed) {
      const fallback = new Ghost(centerX + 2 + i * 0.2, centerY + 2 + i * 0.2, '#ff5555');
      fallback.speed = Math.min(5.2, 3.0 + Math.random() * 0.4);
      ghosts.push(fallback);
    }
  }

  return ghosts;
}

function spawnNatives() {
  const natives = [];
  for (let i = 0; i < CONFIG.nativeCount; i++) {
    const gx = Math.floor(CONFIG.cols / 2 + (i % 2 ? -5 : 5) + (Math.random() * 2 - 1)) + 0.5;
    const gy = Math.floor(CONFIG.rows / 2 + (i < 2 ? -3 : 3) + (Math.random() * 2 - 1)) + 0.5;
    if (!collidesWithWallAt(gameState.map, gx, gy)) {
      natives.push(new NativeFish(gx, gy));
    }
  }
  return natives;
}

function collidesWithWallAt(map, x, y) {
  const radius = CONFIG.collisionRadius;
  const minC = Math.floor(x - radius);
  const maxC = Math.floor(x + radius);
  const minR = Math.floor(y - radius);
  const maxR = Math.floor(y + radius);

  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      if (r < 0 || c < 0 || r >= CONFIG.rows || c >= CONFIG.cols) return true;
      if (map[r][c] === 1) return true;
    }
  }
  return false;
}

// ============= RENDERIZADO =============
function draw() {
  const { ctx, canvas, tile, map, player, ghosts, natives } = gameState;

  // Ajustar tamaño del canvas
  canvas.style.width = gameState.width + 'px';
  canvas.style.height = gameState.height + 'px';

  // Fondo
  ctx.fillStyle = '#00131a';
  ctx.fillRect(0, 0, gameState.width, gameState.height);

  // Dibujar mapa
  for (let r = 0; r < CONFIG.rows; r++) {
    for (let c = 0; c < CONFIG.cols; c++) {
      const x = c * tile;
      const y = r * tile;

      if (map[r][c] === 1) {
        ctx.fillStyle = '#133';
        ctx.fillRect(x, y, tile, tile);
      } else if (map[r][c] === 2) {
        ctx.fillStyle = '#ffd54f';
        ctx.beginPath();
        ctx.arc(x + tile/2, y + tile/2, Math.max(2, tile * 0.08), 0, Math.PI * 2);
        ctx.fill();
      } else if (map[r][c] === 3) {
        ctx.fillStyle = '#093';
        ctx.fillRect(x + 2, y + 2, tile - 4, tile - 4);
      } else if (map[r][c] === 4) {
        const cx = x + tile/2;
        const cy = y + tile/2;
        ctx.fillStyle = '#8be04f';
        ctx.beginPath();
        ctx.arc(cx, cy, tile * 0.18, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#2b5e2b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, tile * 0.28, Math.PI * 0.4, Math.PI * 1.2);
        ctx.stroke();
      }
    }
  }

  // Dibujar entidades
  player.draw(ctx, tile);
  natives.forEach(n => n.draw(ctx, tile));
  ghosts.forEach(g => g.draw(ctx, tile));
}

// ============= ACTUALIZACIÓN =============
function update(delta) {
  if (!gameState.running || gameState.paused) return;

  const now = performance.now();

  // Expirar escondite
  if (gameState.player.hidden && now > gameState.player.hideExpires) {
    gameState.player.hidden = false;
    document.getElementById('hide-indicator').style.display = 'none';
  }

  // Cambiar dirección del jugador
  if (gameState.player.nextDir.x !== 0 || gameState.player.nextDir.y !== 0) {
    const testX = gameState.player.x + gameState.player.nextDir.x * 0.25;
    const testY = gameState.player.y + gameState.player.nextDir.y * 0.25;
    if (!gameState.player.collidesWithWall(gameState.map, testX, testY)) {
      gameState.player.dir = { ...gameState.player.nextDir };
    }
  }

  // Mover jugador
  gameState.player.tryMove(gameState.map, gameState.player.getSpeed(now), delta);
  gameState.player.x = clamp(gameState.player.x, 0.12, CONFIG.cols - 0.12);
  gameState.player.y = clamp(gameState.player.y, 0.12, CONFIG.rows - 0.12);

  // Recoger items
  const pr = Math.floor(gameState.player.y);
  const pc = Math.floor(gameState.player.x);
  if (gameState.player.collectItem(gameState.map, pr, pc)) {
    updateHUD();
    if (gameState.pelletsRemaining <= 0) nextLevel();
  }

  // Actualizar nativos
  gameState.natives.forEach(n => {
    n.updateAI(gameState.map);
    n.tryMove(gameState.map, n.getSpeed(now), delta);

    const nr = Math.floor(n.y);
    const nc = Math.floor(n.x);
    if (n.collectItem(gameState.map, nr, nc)) {
      updateHUD();
      if (gameState.pelletsRemaining <= 0) nextLevel();
    }
  });

  // Actualizar fantasmas
  gameState.ghosts.forEach(g => {
    g.updateAI(gameState.player, gameState.level);
    g.tryMove(gameState.map, g.speed, delta);

    if (g.checkCollision(gameState.player)) {
      // Ya se reinició el nivel o el juego
      return;
    }
  });
}

function nextLevel() {
  gameState.level++;
  if (gameState.level > CONFIG.maxLevel) {
    alert('¡Felicidades! completaste todos los niveles.');
    resetGame();
  } else {
    startLevel(gameState.level);
  }
}

// ============= CONTROL =============
function setupInput() {
  window.addEventListener('keydown', (e) => {
    const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
    if (keys.includes(e.key)) e.preventDefault();

    if (!gameState.player) return;

    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') gameState.player.nextDir = { x: 0, y: -1 };
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') gameState.player.nextDir = { x: 0, y: 1 };
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') gameState.player.nextDir = { x: -1, y: 0 };
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') gameState.player.nextDir = { x: 1, y: 0 };
  });
}

// ============= LOOP =============
function gameLoop(timestamp) {
  if (!gameState.lastTime) gameState.lastTime = timestamp;
  const delta = timestamp - gameState.lastTime;
  gameState.lastTime = timestamp;

  update(delta);
  draw();

  if (gameState.running) {
    requestAnimationFrame(gameLoop);
  }
}

// ============= INICIALIZACIÓN =============
function resizeCanvas() {
  const marginX = 60;
  const marginY = 160;
  const availW = Math.max(300, window.innerWidth - marginX);
  const availH = Math.max(300, window.innerHeight - marginY);
  const maxSize = Math.min(availW, availH);

  gameState.tile = Math.floor(maxSize / Math.max(CONFIG.cols, CONFIG.rows));
  if (gameState.tile < 14) gameState.tile = 14;

  gameState.width = CONFIG.cols * gameState.tile;
  gameState.height = CONFIG.rows * gameState.tile;
  gameState.canvas.width = gameState.width;
  gameState.canvas.height = gameState.height;
}

function startLevel(level) {
  gameState.map = generateMap(CONFIG.cols, CONFIG.rows);
  gameState.player = new Player(Math.floor(CONFIG.cols / 2) + 0.5, Math.floor(CONFIG.rows / 2) + 0.5);
  gameState.ghosts = spawnGhosts(level);
  gameState.natives = spawnNatives();
  gameState.pelletsRemaining = countPellets(gameState.map);

  gameState.running = true;
  gameState.paused = false;
  updateHUD();
}

function resetGame() {
  gameState.level = 1;
  gameState.lives = CONFIG.initialLives;
  gameState.score = 0;
  startLevel(1);
}

function updateHUD() {
  document.getElementById('pf-level').textContent = gameState.level;
  document.getElementById('pf-lives').textContent = gameState.lives;
  document.getElementById('pf-score').textContent = gameState.score;
  document.getElementById('pf-pellets').textContent = gameState.pelletsRemaining;
  document.getElementById('pf-natives').textContent = gameState.natives.length;
}

// ============= INICIO =============
(function init() {
  gameState.canvas = document.getElementById('pf-canvas');
  gameState.ctx = gameState.canvas.getContext('2d');

  window.addEventListener('resize', () => {
    resizeCanvas();
    draw();
  });

  resizeCanvas();
  setupInput();

  document.getElementById('pf-start').addEventListener('click', () => {
    resetGame();
    gameState.lastTime = 0;
    requestAnimationFrame(gameLoop);
  });

  document.getElementById('pf-pause').addEventListener('click', () => {
    gameState.paused = !gameState.paused;
    document.getElementById('pf-pause').textContent = gameState.paused ? 'Reanudar' : 'Pausa';
  });

  startLevel(1);
  updateHUD();
})();
</script>
</body>
</html>
