<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>IcTiosCusco — Juego PAC-Fish</title>
  <meta name="description" content="PAC-Fish: juego educativo inspirado en Pac-Man con peces y truchas.">

  <!-- Estilos y fuentes (consistentes con el sitio) -->
  <link href="https://fonts.googleapis.com/css?family=Dosis:200,300,400,500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Overpass:300,400,400i,600,700" rel="stylesheet">
  <link rel="stylesheet" href="css/open-iconic-bootstrap.min.css">
  <link rel="stylesheet" href="css/animate.css">
  <link rel="stylesheet" href="css/style.css">

  <style>
    body { background: linear-gradient(180deg,#f6fbfd,#eef7fa); }
    .game-wrap { padding: 40px 0; }
    #pf-canvas { border-radius:12px; background:#012; display:block; margin:0 auto; box-shadow:0 10px 30px rgba(0,0,0,0.18); }
    .controls { text-align:center; margin-top:14px; }
    .info { text-align:center; margin-bottom:10px; }
    .back-link { position: fixed; left: 16px; top: 16px; z-index:1000 }
    /* Indicador de escondite */
    .hide-badge { display:inline-block; padding:6px 10px; border-radius:16px; background:#2f8f66; color:#fff; font-size:0.9rem; margin-left:8px }
  </style>
</head>
<body>

<a class="btn btn-outline-secondary back-link" href="recursos.html">← Volver a Recursos</a>

<main class="container game-wrap">
  <div class="row justify-content-center">
    <div class="col-md-8 text-center">
      <h1>PAC-Fish</h1>
      <p class="lead">Elige tu pez y evita a las truchas. Usa ← → ↑ ↓ o WASD. 30 niveles.</p>

      <div style="margin-bottom:8px;">
        <label style="margin-right:10px;"><input type="radio" name="pf-character" value="orestia" checked> Orestia</label>
        <label style="margin-right:10px;"><input type="radio" name="pf-character" value="sardina"> Sardina</label>
        <label><input type="radio" name="pf-character" value="bagre"> Bagre</label>
      </div>

      <div class="info">Nivel: <span id="pf-level">1</span> · Vidas: <span id="pf-lives">3</span> · Puntos: <span id="pf-score">0</span> <span id="hide-indicator" class="hide-badge" style="display:none">En escondite</span></div>

      <canvas id="pf-canvas" width="520" height="520"></canvas>

      <div class="controls">
        <button id="pf-start" class="btn btn-primary">Iniciar / Reiniciar</button>
        <button id="pf-pause" class="btn btn-secondary">Pausa</button>
      </div>

      <p style="margin-top:12px; color:#666; font-size:0.95rem;">Sugerencia: para mejor experiencia usa un desktop o laptop. En móviles, usa orientación horizontal.</p>
    </div>
  </div>
</main>

<script>
/* PAC-FISH mejorado: más truchas, más rápidas, escondites en esquinas (invulnerabilidad temporal), mapa abierto sin muros internos. */
const PF_CONFIG = { tileSize:20, cols:26, rows:26, initialLives:3, maxLevel:30 };

// Tiles: 0 = empty, 1 = wall (borde), 2 = pellet, 3 = hide spot
function generateMap(cols, rows) {
  const map = Array(rows).fill().map(()=>Array(cols).fill(2));
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      if (r===0||c===0||r===rows-1||c===cols-1) map[r][c]=1; // borde
    }
  }
  // colocamos 4 escondites en cada esquina (3x3) y eliminamos pellets dentro
  const corners = [ {r:1,c:1}, {r:1,c:cols-3}, {r:rows-3,c:1}, {r:rows-3,c:cols-3} ];
  corners.forEach(pt => {
    for (let dr=0; dr<3; dr++) for (let dc=0; dc<3; dc++) {
      const rr = pt.r + dr; const cc = pt.c + dc;
      if (rr>0 && cc>0 && rr<rows-1 && cc<cols-1) map[rr][cc] = 3; // hide
    }
  });

  // guardamos centros de escondites para spawn/indicador
  map.__hideCenters = corners.map(pt => ({r: pt.r+1, c: pt.c+1}));

  // dejar espacio central para spawn sin pellets
  const cx = Math.floor(cols/2), cy = Math.floor(rows/2);
  for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) map[cy+dr][cx+dc] = 0;
  return map;
}

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
class Entity{constructor(x,y){this.x=x;this.y=y;this.dir={x:0,y:0}}}
class Player extends Entity{constructor(x,y){super(x,y);this.nextDir={x:0,y:0}; this.hidden=false; this.hideExpires=0; this.hideCooldowns=[0,0,0,0];}}
class Ghost extends Entity{constructor(x,y,color){super(x,y);this.color=color||'#f55';this.speed=1; this.dir = {x:0,y:0};}}

const canvas = document.getElementById('pf-canvas'); const ctx = canvas.getContext('2d');
const cfg = PF_CONFIG; const WIDTH = cfg.cols*cfg.tileSize; const HEIGHT = cfg.rows*cfg.tileSize; canvas.width=WIDTH; canvas.height=HEIGHT;
let map = generateMap(cfg.cols,cfg.rows); let player, ghosts, score, lives, level, pelletsRemaining; let running=false, paused=false;
let lastTime = performance.now();

function resetGame(){ level=1; lives=cfg.initialLives; score=0; startLevel(level); updateHUD(); }

function startLevel(l){
  map = generateMap(cfg.cols,cfg.rows);
  // player spawn en centro
  player = new Player(Math.floor(cfg.cols/2)+0.5, Math.floor(cfg.rows/2)+0.5);
  player.dir={x:0,y:0}; player.nextDir={x:0,y:0}; player.hidden=false; player.hideExpires=0; player.hideCooldowns=[0,0,0,0];

  ghosts=[];
  // más fantasmas y más agresivos: base aumenta rápido con nivel
  const baseGhosts = Math.min(12, Math.floor(3 + l*0.6));
  for(let i=0;i<baseGhosts;i++){
    // spawn en posiciones alrededor del centro con offset
    const angle = (i / baseGhosts) * Math.PI * 2;
    const gx = Math.floor(cfg.cols/2 + Math.cos(angle)*3);
    const gy = Math.floor(cfg.rows/2 + Math.sin(angle)*3);
    const g = new Ghost(gx+0.5, gy+0.5, '#'+(Math.floor(Math.random()*16777215).toString(16)));
    // velocidad escala por nivel (más difícil)
    g.speed = Math.min(3.0, 0.9 + l * 0.12 + Math.random()*0.4);
    ghosts.push(g);
  }

  // Contar pellets (solo tiles === 2)
  pelletsRemaining = 0;
  for (let r=0;r<cfg.rows;r++) for (let c=0;c<cfg.cols;c++) if (map[r][c]===2) pelletsRemaining++;

  running = true; paused=false; updateHUD();
}

function draw() {
  // fondo
  ctx.fillStyle = '#00131a';
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // dibujar pellets y escondites y borde
  for (let r=0;r<cfg.rows;r++){
    for (let c=0;c<cfg.cols;c++){
      const x = c*cfg.tileSize, y = r*cfg.tileSize;
      if (map[r][c]===1) {
        ctx.fillStyle = '#133';
        ctx.fillRect(x,y,cfg.tileSize,cfg.tileSize);
      } else if (map[r][c]===2) {
        ctx.fillStyle = '#ffd54f';
        const cx = x + cfg.tileSize/2, cy = y + cfg.tileSize/2;
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(2, cfg.tileSize*0.09), 0, Math.PI*2); ctx.fill();
      } else if (map[r][c]===3) {
        // escondite: dibujar marca (hojas / algas) y borde
        ctx.fillStyle = '#093';
        ctx.fillRect(x+2, y+2, cfg.tileSize-4, cfg.tileSize-4);
        ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(x+2, y+2, cfg.tileSize-4, cfg.tileSize-4);
      }
    }
  }

  // dibujar player
  const px = player.x*cfg.tileSize, py = player.y*cfg.tileSize;
  ctx.save();
  ctx.translate(px + cfg.tileSize/2, py + cfg.tileSize/2);
  const sel = document.querySelector('input[name="pf-character"]:checked').value;
  let pColor = '#FFD700';
  if (sel === 'sardina') pColor = '#6ECFF6';
  if (sel === 'bagre') pColor = '#A07C4A';
  // si está escondido, dibujar halo
  if (player.hidden) {
    ctx.beginPath(); ctx.arc(0,0,cfg.tileSize*0.65,0,Math.PI*2);
    ctx.fillStyle = 'rgba(46,204,113,0.18)'; ctx.fill();
    ctx.strokeStyle = 'rgba(46,204,113,0.35)'; ctx.lineWidth = 2; ctx.stroke();
  }
  ctx.fillStyle = pColor; ctx.beginPath(); ctx.arc(0,0, cfg.tileSize*0.4, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // dibujar fantasmas (truchas)
  ghosts.forEach(g => {
    const gx = g.x*cfg.tileSize + cfg.tileSize/2;
    const gy = g.y*cfg.tileSize + cfg.tileSize/2;
    // cuerpo
    ctx.fillStyle = g.color; ctx.beginPath(); ctx.ellipse(gx, gy, cfg.tileSize*0.45, cfg.tileSize*0.35, 0, 0, Math.PI*2); ctx.fill();
    // ojos
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(gx - cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(gx - cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.05, 0, Math.PI*2); ctx.fill();
  });
}

function isWallAt(px,py){ const c=Math.floor(px), r=Math.floor(py); if(r<0||c<0||r>=cfg.rows||c>=cfg.cols) return true; return map[r][c]===1; }

function update(delta) {
  if (!running || paused) return;

  const now = performance.now();
  // manejar estado escondite del jugador (tiempo restante)
  if (player.hidden && now > player.hideExpires) {
    player.hidden = false;
    document.getElementById('hide-indicator').style.display = 'none';
  }

  // intentar cambiar dirección
  if (player.nextDir.x !== 0 || player.nextDir.y !== 0) {
    const nx = player.x + player.nextDir.x * 0.2;
    const ny = player.y + player.nextDir.y * 0.2;
    if (!isWallAt(nx, ny)) player.dir = {...player.nextDir};
  }

  // velocidad del jugador
  const pSpeed = 3.6; // tiles/sec (ligeramente más ágil)
  player.x += player.dir.x * pSpeed * (delta/1000);
  player.y += player.dir.y * pSpeed * (delta/1000);
  player.x = clamp(player.x, 0.1, cfg.cols - 0.9);
  player.y = clamp(player.y, 0.1, cfg.rows - 0.9);

  // interacción con tiles: pellets y escondites
  const pr = Math.floor(player.y), pc = Math.floor(player.x);
  if (map[pr][pc] === 2) {
    map[pr][pc] = 0; pelletsRemaining--; score += 10; updateHUD();
    if (pelletsRemaining <= 0) {
      level++;
      if (level > cfg.maxLevel) { alert('¡Felicidades! Completaste todos los niveles.'); resetGame(); return; }
      else { startLevel(level); return; }
    }
  } else if (map[pr][pc] === 3) {
    // calcular cuál esquina y si cooldown permite entrar
    const centers = map.__hideCenters; let cornerIndex = -1;
    centers.forEach((cpt, idx) => { if (Math.abs(pr - cpt.r) <=1 && Math.abs(pc - cpt.c) <=1) cornerIndex = idx; });
    if (cornerIndex >= 0) {
      const nowms = Date.now();
      // si cooldown pasó, activar escondite
      if (nowms > player.hideCooldowns[cornerIndex]) {
        player.hidden = true; player.hideExpires = nowms + 5000; // 5s invulnerable
        player.hideCooldowns[cornerIndex] = nowms + 15000; // cooldown 15s para esa esquina
        document.getElementById('hide-indicator').style.display = 'inline-block';
      }
    }
  }

  // fantasmas: IA mejorada
  ghosts.forEach(g => {
    // distancia al jugador
    const dx = player.x - g.x, dy = player.y - g.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // comportamiento: si el jugador no está escondido y está cerca -> perseguir (agresivo)
    let targetDir = {x:0, y:0};
    if (!player.hidden && dist < Math.max(6, 7 - Math.min(3, level*0.05))) {
      // perseguir: elegir eje mayor
      if (Math.abs(dx) > Math.abs(dy)) targetDir.x = dx > 0 ? 1 : -1;
      else targetDir.y = dy > 0 ? 1 : -1;
    } else {
      // movimiento más agresivo: intenta moverse hacia el centro para cortar caminos y patrullar
      const cx = cfg.cols/2 - 1, cy = cfg.rows/2 - 1;
      const cdx = cx - g.x, cdy = cy - g.y;
      if (Math.random() < 0.5) {
        if (Math.abs(cdx) > Math.abs(cdy)) targetDir.x = cdx>0?1:-1; else targetDir.y = cdy>0?1:-1;
      } else {
        // movimiento aleatorio con mayor probabilidad de cambiar dirección en niveles altos
        if (Math.random() < 0.18 + level*0.01) {
          const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
          targetDir = dirs[Math.floor(Math.random()*dirs.length)];
        } else targetDir = g.dir || {x:0,y:0};
      }
    }

    // aplicar movimiento con velocidad
    const newX = g.x + targetDir.x * g.speed * (delta/1000);
    const newY = g.y + targetDir.y * g.speed * (delta/1000);
    if (!isWallAt(newX, newY)) { g.x = newX; g.y = newY; g.dir = targetDir; }
    else {
      // si choca, elegir alternativa rápida
      const alts = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      const alt = alts[Math.floor(Math.random()*alts.length)];
      const ax = g.x + alt.x * g.speed * (delta/1000); const ay = g.y + alt.y * g.speed * (delta/1000);
      if (!isWallAt(ax, ay)) { g.x = ax; g.y = ay; g.dir = alt; }
    }

    // colisión con player
    const ddx = player.x - g.x, ddy = player.y - g.y;
    if (!player.hidden && Math.sqrt(ddx*ddx + ddy*ddy) < 0.6) {
      // impacto
      lives--; updateHUD();
      if (lives <= 0) { alert('Juego terminado. Reiniciando...'); resetGame(); }
      else { startLevel(level); }
    }
  });
}

function updateHUD(){ document.getElementById('pf-level').innerText = level; document.getElementById('pf-lives').innerText = lives; document.getElementById('pf-score').innerText = score; }

window.addEventListener('keydown', e=>{ if(!player) return; if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') player.nextDir={x:0,y:-1}; if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') player.nextDir={x:0,y:1}; if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') player.nextDir={x:-1,y:0}; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') player.nextDir={x:1,y:0}; });

function loop(now) {
  const delta = now - lastTime;
  lastTime = now;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

// botones
document.getElementById('pf-start').addEventListener('click', ()=>{ resetGame(); lastTime = performance.now(); requestAnimationFrame(loop); });
document.getElementById('pf-pause').addEventListener('click', ()=>{ paused = !paused; document.getElementById('pf-pause').innerText = paused ? 'Reanudar' : 'Pausa'; });

// inicializar
(function init(){ startLevel(1); updateHUD(); })();

</script>
</body>
</html>


