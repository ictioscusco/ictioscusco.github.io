<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IcTiosCusco — Juego PAC-Fish Mejorado</title>
  <style>
    body { background: linear-gradient(180deg,#f6fbfd,#eef7fa); font-family: Arial, sans-serif; }
    .game-wrap { padding: 24px; text-align:center; }
    #pf-canvas { border-radius:12px; background:#012; display:block; margin:12px auto; box-shadow:0 10px 30px rgba(0,0,0,0.18); }
    .controls { margin-top:10px; }
    .info { margin-bottom:8px; color:#222; }
    .hide-badge { display:inline-block; padding:6px 10px; border-radius:16px; background:#2f8f66; color:#fff; font-size:0.85rem; margin-left:8px }
    button{ padding:8px 12px; margin:0 6px; }
  </style>
</head>
<body>
  <main class="game-wrap">
    <h1>PAC-Fish (Mejorado)</h1>
    <p class="lead">Elige tu pez y evita a las truchas. Usa ← → ↑ ↓ o WASD. 30 niveles.</p>

    <div style="margin-bottom:8px;">
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="orestia" checked> Orestia</label>
      <label style="margin-right:10px;"><input type="radio" name="pf-character" value="sardina"> Sardina</label>
      <label><input type="radio" name="pf-character" value="bagre"> Bagre</label>
    </div>

    <div class="info">
      Nivel: <span id="pf-level">1</span> · Vidas: <span id="pf-lives">3</span> · Puntos: <span id="pf-score">0</span>
      <span id="hide-indicator" class="hide-badge" style="display:none">En escondite</span>
      · Pellets: <span id="pf-pellets">0</span> · Peces nativos: <span id="pf-natives">0</span>
    </div>

    <canvas id="pf-canvas" width="440" height="440"></canvas>

    <div class="controls">
      <button id="pf-start">Iniciar / Reiniciar</button>
      <button id="pf-pause">Pausa</button>
    </div>

    <p style="margin-top:12px; color:#666; font-size:0.95rem;">Sugerencia: mejor en desktop. Los "caracoles/hyalellas" aumentan temporalmente la velocidad.</p>
  </main>

<script>
/*
  PAC-Fish mejorado: mapa más pequeño, obstaculos, peces nativos que comen pellets,
  power-ups (hyalellas/caracoles) que aumentan velocidad temporalmente,
  truchas (fantasmas) más rápidas que peces nativos.
*/

// CONFIGURACIÓN (ajusta si quieres más/menos acción)
const PF_CONFIG = {
  tileSize:22,
  cols:20,           // mapa más pequeño para hacerlo menos aburrido
  rows:20,
  initialLives:3,
  maxLevel:30,
  nativeCount: 4,    // peces nativos que comen pellets
  powerupCount: 4    // cantidad de hyalellas/caracoles por nivel
};

// Tiles: 0 empty, 1 wall, 2 pellet, 3 hide spot, 4 power-up (caracol)
function generateMap(cols, rows) {
  // iniciar con pellets
  const map = Array(rows).fill().map(()=>Array(cols).fill(2));
  // borde
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      if (r===0||c===0||r===rows-1||c===cols-1) map[r][c]=1;
    }
  }

  // añadir obstáculos internos (islas / muros) con un patrón simple y simétrico
  const blocks = [
    {r:4,c:4,h:3,w:3}, {r:4,c:cols-7,h:3,w:3},
    {r:rows-7,c:4,h:3,w:3}, {r:rows-7,c:cols-7,h:3,w:3},
    {r:Math.floor(rows/2)-2,c:Math.floor(cols/2)-1,h:3,w:6}
  ];
  blocks.forEach(b=>{
    for(let rr=0; rr<b.h; rr++) for(let cc=0; cc<b.w; cc++){
      const r = b.r + rr, c = b.c + cc;
      if (r>0 && c>0 && r<rows-1 && c<cols-1) map[r][c]=1;
    }
  });

  // escondites en esquinas 2x2
  const corners = [ {r:1,c:1}, {r:1,c:cols-3}, {r:rows-3,c:1}, {r:rows-3,c:cols-3} ];
  corners.forEach(pt => {
    for (let dr=0; dr<2; dr++) for (let dc=0; dc<2; dc++) {
      const rr = pt.r + dr; const cc = pt.c + dc;
      if (rr>0 && cc>0 && rr<rows-1 && cc<cols-1) map[rr][cc] = 3; // hide
    }
  });
  map.__hideCenters = corners.map(pt => ({r: pt.r, c: pt.c}));

  // dejar spawn central sin pellets 3x3
  const cx = Math.floor(cols/2), cy = Math.floor(rows/2);
  for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
    if (cy+dr>0 && cx+dc>0 && cy+dr<rows-1 && cx+dc<cols-1) map[cy+dr][cx+dc] = 0;
  }

  // colocar power-ups (caracoles/hyalellas) en posiciones abiertas
  map.__powerups = [];
  let attempts = 0;
  while(map.__powerups.length < PF_CONFIG.powerupCount && attempts < 300){
    attempts++;
    const r = 2 + Math.floor(Math.random()*(rows-4));
    const c = 2 + Math.floor(Math.random()*(cols-4));
    if (map[r][c] === 2) { map[r][c] = 4; map.__powerups.push({r,c}); }
  }

  return map;
}

function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

class Entity {
  constructor(x,y){ this.x=x; this.y=y; this.dir={x:0,y:0}; }
}
class Player extends Entity {
  constructor(x,y){ super(x,y); this.nextDir={x:0,y:0}; this.hidden=false; this.hideExpires=0; this.hideCooldowns=[0,0,0,0]; this.speedBoostExpires=0; this.baseSpeed=3.8; }
  getSpeed(now){ return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed; }
}
class Ghost extends Entity {
  constructor(x,y,color){ super(x,y); this.color=color||'#f55'; this.speed=3.2; this.dir={x:0,y:0}; }
}
class NativeFish extends Entity {
  constructor(x,y){ super(x,y); this.baseSpeed=2.1; this.speedBoostExpires=0; this.dir={x:0,y:0}; }
  getSpeed(now){ return now < this.speedBoostExpires ? this.baseSpeed * 1.6 : this.baseSpeed; }
}

/* --- inicialización canvas y variables --- */
const canvas = document.getElementById('pf-canvas'); const ctx = canvas.getContext('2d');
const cfg = PF_CONFIG;
const WIDTH = cfg.cols * cfg.tileSize, HEIGHT = cfg.rows * cfg.tileSize;
canvas.width = WIDTH; canvas.height = HEIGHT;

let map = generateMap(cfg.cols, cfg.rows);
let player, ghosts = [], natives = [], score=0, lives=cfg.initialLives, level=1, pelletsRemaining=0;
let running=false, paused=false, lastTime=performance.now();

function resetGame(){ level=1; lives=cfg.initialLives; score=0; startLevel(level); updateHUD(); }

function spawnGhostsForLevel(l) {
  ghosts = [];
  // cantidad aumentada rápidamente, pero limitada
  const baseGhosts = Math.min(10, Math.floor(2 + l * 0.7));
  for (let i=0;i<baseGhosts;i++){
    const angle = (i / baseGhosts) * Math.PI * 2;
    const gx = Math.floor(cfg.cols/2 + Math.cos(angle)*3);
    const gy = Math.floor(cfg.rows/2 + Math.sin(angle)*3);
    const g = new Ghost(gx+0.5, gy+0.5, '#'+(Math.floor(Math.random()*16777215).toString(16)).padStart(6,'0'));
    // trucha siempre más rápida que peces nativos
    g.speed = Math.min(5.0, 2.8 + l * 0.18 + Math.random()*0.6);
    ghosts.push(g);
  }
  return ghosts;
}

function spawnNatives() {
  natives = [];
  for (let i=0;i<cfg.nativeCount;i++){
    // spawn en alas alrededor del centro pero lejos de player spawn
    const gx = Math.floor(cfg.cols/2 + (i%2? -4:4) + (Math.random()*2-1));
    const gy = Math.floor(cfg.rows/2 + (i<2? -3:3) + (Math.random()*2-1));
    if (gx>1 && gy>1 && gx<cfg.cols-2 && gy<cfg.rows-2) natives.push(new NativeFish(gx+0.5, gy+0.5));
  }
}

function countPellets() {
  let c = 0;
  for (let r=0;r<cfg.rows;r++) for (let col=0; col<cfg.cols; col++) if (map[r][col]===2) c++;
  return c;
}

function startLevel(l) {
  map = generateMap(cfg.cols, cfg.rows);
  player = new Player(Math.floor(cfg.cols/2)+0.5, Math.floor(cfg.rows/2)+0.5);
  player.dir={x:0,y:0}; player.nextDir={x:0,y:0}; player.hidden=false; player.hideExpires=0; player.hideCooldowns=[0,0,0,0]; player.speedBoostExpires=0;

  spawnGhostsForLevel(l);
  spawnNatives();

  pelletsRemaining = countPellets();
  running = true; paused=false;
  updateHUD();
}

/* --- DIBUJADO --- */
function draw() {
  // fondo
  ctx.fillStyle = '#00131a';
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // tiles
  for (let r=0;r<cfg.rows;r++){
    for (let c=0;c<cfg.cols;c++){
      const x = c*cfg.tileSize, y = r*cfg.tileSize;
      if (map[r][c]===1) {
        ctx.fillStyle = '#133'; ctx.fillRect(x,y,cfg.tileSize,cfg.tileSize);
      } else if (map[r][c]===2) {
        ctx.fillStyle = '#ffd54f';
        const cx = x + cfg.tileSize/2, cy = y + cfg.tileSize/2;
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(2, cfg.tileSize*0.08), 0, Math.PI*2); ctx.fill();
      } else if (map[r][c]===3) {
        ctx.fillStyle = '#093'; ctx.fillRect(x+2, y+2, cfg.tileSize-4, cfg.tileSize-4);
      } else if (map[r][c]===4) {
        // power-up: dibujar caracol/hyalella (ícono simple)
        const cx = x + cfg.tileSize/2, cy = y + cfg.tileSize/2;
        ctx.fillStyle = '#8be04f';
        ctx.beginPath(); ctx.arc(cx, cy, cfg.tileSize*0.18, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#2b5e2b'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, cfg.tileSize*0.28, Math.PI*0.4, Math.PI*1.2); ctx.stroke();
      }
    }
  }

  // player
  const px = player.x*cfg.tileSize, py = player.y*cfg.tileSize;
  ctx.save(); ctx.translate(px + cfg.tileSize/2, py + cfg.tileSize/2);
  const sel = document.querySelector('input[name="pf-character"]:checked').value;
  let pColor = '#FFD700';
  if (sel === 'sardina') pColor = '#6ECFF6';
  if (sel === 'bagre') pColor = '#A07C4A';
  if (player.hidden) {
    ctx.beginPath(); ctx.arc(0,0,cfg.tileSize*0.7,0,Math.PI*2); ctx.fillStyle='rgba(46,204,113,0.14)'; ctx.fill();
    ctx.strokeStyle='rgba(46,204,113,0.28)'; ctx.lineWidth=2; ctx.stroke();
  }
  ctx.fillStyle = pColor; ctx.beginPath(); ctx.arc(0,0, cfg.tileSize*0.42, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // natives
  natives.forEach(n=>{
    const gx = n.x*cfg.tileSize + cfg.tileSize/2;
    const gy = n.y*cfg.tileSize + cfg.tileSize/2;
    ctx.fillStyle = '#9ae0ff';
    ctx.beginPath(); ctx.ellipse(gx, gy, cfg.tileSize*0.35, cfg.tileSize*0.22, 0, 0, Math.PI*2); ctx.fill();
    // si speedboost activo, halo pequeño
    if (Date.now() < n.speedBoostExpires) {
      ctx.strokeStyle = 'rgba(138,224,255,0.45)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(gx,gy,cfg.tileSize*0.46,0,Math.PI*2); ctx.stroke();
    }
  });

  // ghosts (truchas)
  ghosts.forEach(g => {
    const gx = g.x*cfg.tileSize + cfg.tileSize/2;
    const gy = g.y*cfg.tileSize + cfg.tileSize/2;
    ctx.fillStyle = g.color; ctx.beginPath(); ctx.ellipse(gx, gy, cfg.tileSize*0.46, cfg.tileSize*0.36, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(gx - cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(gx - cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + cfg.tileSize*0.12, gy - cfg.tileSize*0.05, cfg.tileSize*0.05, 0, Math.PI*2); ctx.fill();
  });
}

/* --- FÍSICA y IA --- */
function isWallAt(px,py){
  const c=Math.floor(px), r=Math.floor(py);
  if (r<0||c<0||r>=cfg.rows||c>=cfg.cols) return true;
  return map[r][c]===1;
}

function tryMoveEntity(entity, dx, dy, speed, delta) {
  const nx = entity.x + dx * speed * (delta/1000);
  const ny = entity.y + dy * speed * (delta/1000);
  if (!isWallAt(nx, ny)) { entity.x = nx; entity.y = ny; return true; }
  return false;
}

function update(delta) {
  if (!running || paused) return;
  const now = Date.now();

  // esconderse
  if (player.hidden && now > player.hideExpires) {
    player.hidden = false; document.getElementById('hide-indicator').style.display='none';
  }

  // cambiar dirección si se intentó
  if (player.nextDir.x !== 0 || player.nextDir.y !== 0) {
    const nx = player.x + player.nextDir.x * 0.25, ny = player.y + player.nextDir.y * 0.25;
    if (!isWallAt(nx, ny)) player.dir = {...player.nextDir};
  }

  // mover jugador
  const pSpeed = player.getSpeed(now);
  player.x += player.dir.x * pSpeed * (delta/1000);
  player.y += player.dir.y * pSpeed * (delta/1000);
  player.x = clamp(player.x, 0.1, cfg.cols - 0.9);
  player.y = clamp(player.y, 0.1, cfg.rows - 0.9);

  // interacción jugador con tiles
  const pr = Math.floor(player.y), pc = Math.floor(player.x);
  if (map[pr][pc] === 2) {
    map[pr][pc] = 0; pelletsRemaining--; score += 10; updateHUD();
    if (pelletsRemaining <= 0) {
      level++;
      if (level > cfg.maxLevel) { alert('¡Felicidades! Completaste todos los niveles.'); resetGame(); return; }
      else { startLevel(level); return; }
    }
  } else if (map[pr][pc] === 3) {
    // escondite
    const centers = map.__hideCenters; let cornerIndex=-1;
    centers.forEach((cpt, idx) => { if (Math.abs(pr - cpt.r) <=1 && Math.abs(pc - cpt.c) <=1) cornerIndex = idx; });
    if (cornerIndex >= 0) {
      const nowms = Date.now();
      if (nowms > player.hideCooldowns[cornerIndex]) {
        player.hidden = true; player.hideExpires = nowms + 5000; player.hideCooldowns[cornerIndex] = nowms + 15000;
        document.getElementById('hide-indicator').style.display = 'inline-block';
      }
    }
  } else if (map[pr][pc] === 4) {
    // power-up: incrementar velocidad temporalmente
    map[pr][pc] = 0;
    player.speedBoostExpires = Date.now() + 7000; // 7s
    score += 30; updateHUD();
  }

  // actualizar peces nativos (comen pellets y powerups)
  natives.forEach(n => {
    // comportamiento simple: si hay pellet cercano, moverse hacia él con algo de probabilidad; 
    // si no, movimiento aleatorio
    const nowMs = Date.now();
    if (Math.random() < 0.14) {
      // escoger dirección aleatoria o hacia pellet cercano
      // buscar pellet en radio 5
      let target = null; let bestD=999;
      for (let r = Math.max(1, Math.floor(n.y)-5); r <= Math.min(cfg.rows-2, Math.floor(n.y)+5); r++){
        for (let c = Math.max(1, Math.floor(n.x)-5); c <= Math.min(cfg.cols-2, Math.floor(n.x)+5); c++){
          if (map[r][c] === 2) {
            const dx = (c+0.5) - n.x, dy = (r+0.5) - n.y; const d = Math.sqrt(dx*dx + dy*dy);
            if (d < bestD) { bestD = d; target = {dx: dx/d, dy: dy/d}; }
          }
        }
      }
      if (target) n.dir = {x: Math.sign(target.dx), y: Math.sign(target.dy)};
      else {
        const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        n.dir = dirs[Math.floor(Math.random()*dirs.length)];
      }
    }

    // mover
    const ns = n.getSpeed(nowMs);
    tryMoveEntity(n, n.dir.x, n.dir.y, ns, delta);

    // interacción con tile
    const nr = Math.floor(n.y), nc = Math.floor(n.x);
    if (map[nr][nc] === 2) {
      map[nr][nc] = 0; pelletsRemaining--; score += 2; // suman pocos puntos
      if (pelletsRemaining <= 0) {
        level++;
        if (level > cfg.maxLevel) { alert('¡Felicidades! Completaste todos los niveles.'); resetGame(); return; }
        else { startLevel(level); return; }
      }
    } else if (map[nr][nc] === 4) {
      map[nr][nc] = 0; n.speedBoostExpires = Date.now() + 7000; // native picks power-up and gets faster
    }
  });

  // fantasmas: IA agresiva y rápida (persecución directa cuando cerca)
  ghosts.forEach(g => {
    const dx = player.x - g.x, dy = player.y - g.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    let targetDir = {x:0,y:0};
    // si el jugador no está escondido y está cerca -> persecución directa
    if (!player.hidden && dist < Math.max(7, 8 - Math.min(3, level*0.06))) {
      if (Math.abs(dx) > Math.abs(dy)) targetDir.x = dx > 0 ? 1 : -1;
      else targetDir.y = dy > 0 ? 1 : -1;
    } else {
      // patrulla hacia centro o movimiento aleatorio
      const cx = cfg.cols/2 - 1, cy = cfg.rows/2 - 1;
      const cdx = cx - g.x, cdy = cy - g.y;
      if (Math.random() < 0.5) {
        if (Math.abs(cdx) > Math.abs(cdy)) targetDir.x = cdx>0?1:-1; else targetDir.y = cdy>0?1:-1;
      } else {
        if (Math.random() < 0.18 + level*0.01) {
          const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
          targetDir = dirs[Math.floor(Math.random()*dirs.length)];
        } else targetDir = g.dir || {x:0,y:0};
      }
    }

    // mover con mayor velocidad que natives
    const newX = g.x + targetDir.x * g.speed * (delta/1000);
    const newY = g.y + targetDir.y * g.speed * (delta/1000);
    if (!isWallAt(newX, newY)) { g.x = newX; g.y = newY; g.dir = targetDir; }
    else {
      // alternativa si choque
      const alts = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      const alt = alts[Math.floor(Math.random()*alts.length)];
      const ax = g.x + alt.x * g.speed * (delta/1000); const ay = g.y + alt.y * g.speed * (delta/1000);
      if (!isWallAt(ax, ay)) { g.x = ax; g.y = ay; g.dir = alt; }
    }

    // colisión con el jugador
    const ddx = player.x - g.x, ddy = player.y - g.y;
    if (!player.hidden && Math.sqrt(ddx*ddx + ddy*ddy) < 0.6) {
      lives--; updateHUD();
      if (lives <= 0) { alert('Juego terminado. Reiniciando...'); resetGame(); }
      else { startLevel(level); }
    }

    // fantasmas no comen pellets en esta versión (se pueden ajustar si quieres)
  });

  updateHUD();
}

/* --- HUD y controles --- */
function updateHUD(){
  document.getElementById('pf-level').innerText = level;
  document.getElementById('pf-lives').innerText = lives;
  document.getElementById('pf-score').innerText = score;
  document.getElementById('pf-pellets').innerText = pelletsRemaining;
  document.getElementById('pf-natives').innerText = natives.length;
}

window.addEventListener('keydown', e=>{
  if(!player) return;
  if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') player.nextDir={x:0,y:-1};
  if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') player.nextDir={x:0,y:1};
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') player.nextDir={x:-1,y:0};
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') player.nextDir={x:1,y:0};
});

function loop(now) {
  const delta = now - lastTime; lastTime = now;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

/* --- botones --- */
document.getElementById('pf-start').addEventListener('click', ()=>{
  resetGame();
  lastTime = performance.now();
  requestAnimationFrame(loop);
});
document.getElementById('pf-pause').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('pf-pause').innerText = paused ? 'Reanudar' : 'Pausa';
});

/* iniciar primero nivel (pero no lanzar loop hasta click iniciar) */
(function init(){
  startLevel(1);
  updateHUD();
})();
</script>
</body>
</html>
